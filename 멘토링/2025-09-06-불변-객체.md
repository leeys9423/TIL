# 불변 객체

불변객체란? 한 번 생성된 후에는 내부 상태가 절대 변경되지 않습니다. 만약 값을 변경해야 한다면, 기존 객체를 수정하는 것이 아니라 새로운 객체를 생성해야 합니다.

## 메인질문: Java에서 불변 객체와 가변 객체의 장단점을 비교하고, 불변 객체를 생성할 때 고려해야 할 사항은?

### 불변 객체의 장점

**실수 방지**가 핵심이라고 생각합니다.

구체적으로:

- **스레드 안정성**: 여러 스레드가 동시에 접근해도 안전합니다.
- **예측 가능한 동작**: 객체 상태가 변하지 않아 디버깅이 쉽고 코드 이해가 명확합니다.
- **방어적 복사 불필요**: 참조를 그대로 공유해도 안전합니다.

### 불변 객체의 단점

- **성능 오버헤드**: 값 변경 시 마다 새 객체 생성으로 인한 GC 압박
- **복잡한 객체 생성**: Builder 패턴 등 추가적인 구현이 필요할 수 있습니다.

### 가변 객체의 장단점

- **장점**: 메모리 효율적, 상태 변경이 빠름
- **단점**: 스레드 안전성 문제, 예기치 않은 상태 변경 위험

### 불변 객체 생성 시 고려사항

1. 모든 필드를 `final`로 선언
2. `setter` 메서드 제공하지 않기
3. 클래스를 final로 선언 (상속 방지)
4. 가변 필드의 방어적 복사
5. 생성자에서 완전한 초기화: 객체 생성 시 모든 상태가 결정되어야 합니다.

## 꼬리질문: 불변 객체를 생성하는 것이 성능에 어떤 영향을 미치는가?

불변 객체는 확실히 성능 오버헤드가 있습니다. 가장 큰 이유는 상태를 변경할 때마다 새로운 객체를 생성해야 하기 때문입니다.

예를 들어 String을 반복문에서 연결할 때를 생각해보시면, 'Hello' + 'World' + '!' 이렇게 할 때마다 새로운 String 객체가 만들어집니다. 1000번 반복한다면 1000개의 중간 객체들이 생성되죠. 이는 힙 메모리 사용량을 늘리고 가비지 컬렉션의 부담도 증가시킵니다.

하지만 JVM이 많이 최적화해줍니다. String 리터럴은 상수 풀에서 재사용하고, -128부터 127까지의 Integer는 미리 캐시해둡니다. 그래서 실제로는 생각보다 성능 영향이 적은 경우도 많습니다.

성능이 중요한 상황에서는 StringBuilder처럼 가변 객체를 사용하거나, 객체 생성 빈도를 줄이는 설계를 고려해야 합니다.

## 꼬리질문: 복합 객체에서 불변성을 유지하는 방법은 무엇인가?

복합 객체의 불변성은 단순히 final만으로는 부족합니다. final은 참조 자체의 변경만 막을 뿐입니다.

예를 들어 List 필드가 있다면, final List라고 해도 add나 remove 메서드로 내부 요소는 변경할 수 있습니다. 그래서 몇 가지 추가 작업이 필요합니다.

첫째는 방어적 복사입니다. 생성자에서 매개변수를 받을 때 새로운 컬렉션을 만들어서 복사하고, getter에서도 원본이 아닌 복사본을 반환해야 합니다.

둘째는 불변 컬렉션을 사용하는 것입니다. Collections.unmodifiableList나 Guava의 ImmutableList 같은 것들이죠.

셋째는 중첩된 객체들도 모두 불변이어야 한다는 점입니다. Person 객체의 리스트를 가진다면, Person 자체도 불변 객체여야 진정한 불변성이 보장됩니다.

## 꼬리질문: 동시성에서 불변 객체가 갖는 이점은?

가장 큰 이점은 스레드 안전성입니다. 상태가 변하지 않으니까 여러 스레드가 동시에 접근해도 데이터 레이스나 일관성 문제가 발생하지 않습니다.

그래서 `synchronized`나 `volatile` 같은 동기화 메커니즘이 전혀 필요 없습니다. 이는 성능상으로도 큰 이점이죠. 락을 기다릴 필요가 없게됩니다.

## 꼬리질문: 새로운 불변 객체를 설계할 때 주의해야 할 점은 무엇인가?

먼저 클래스를 final로 선언해서 상속을 막아야 합니다. 하위 클래스에서 가변 메서드를 추가할 수 있기 때문입니다.

모든 필드는 private final로 선언하고, setter 메서드는 절대 제공하지 않습니다.

생성자에서는 매개변수 유효성을 반드시 검사해야 합니다. (null 체크나 범위 검사 등)

가변 객체를 필드로 가진다면 방어적 복사가 필수입니다.
