# 예외 처리

프로그램 실행 중에 발생할 수 있는 예외적인 상황을 관리하고 대응하는 메커니즘

예외 처리를 통해 프로그램의 안정성과 신뢰성을 높일 수 있으며, 예상치 못한 오류로부터 프로그램을 보호할 수 있습니다.

## try-catch-finally

### 기본구조

```java
try {
    // 예외가 발생할 수 있는 코드
} catch (ExceptionType1 e) {
    // ExceptionType1 처리
} catch (ExceptionType2 e) {
    // ExceptionType2 처리
} finally {
    // 항상 실행되는 코드 (선택사항)
}
```

### 각 블록의 역할

- **try 블록**: 예외가 발생할 가능성이 있는 코드를 포함
- **catch 블록**: 특정 예외 타입을 잡아서 처리. 여러 개의 catch 블록을 사용할 수 있으며, 구체적인 예외로부터 일반적으로 예외 순서로 배치
- **finally 블록**: 예외 발생 여부와 관계없이 항상 실행. 주로 리소스 정리 작업에 사용

### 특징

catch 구문에 return 문이 있어도 finally 블록은 실행(일반적인 상황에서는 거의 실행되며, 예외적으로 실행되지 않는 경우도 있음!)

1. System.exit() 호출
   ```java
    try {
        System.exit(0); // JVM 종료
    } finally {
        System.out.println("실행되지 않음");
    }
   ```
2. JVM 크래시
3. 무한 루프나 데드락
4. Thread.interrupt() 등으로 인한 강제 종료

### 권장사항

- finally 블록에서는 return문 사용을 피하는 것이 좋음. 코드의 가독성과 예측 가능성을 해치게 됨.
- finally 블록은 주로 리소스 정리 작업에 사용할 것

## try-with-resource (Java 7+)

AutoCloseable 인터페이스를 구현한 리소스를 자동으로 닫아주는 문법

finally 블록에서 수동으로 리소스를 닫을 필요가 없어짐

### 기본구조

```java
try (ResourceType resource = new ResourceType()) {
    // 리소스 사용 코드
} catch (ExceptionType e) {
    // 예외 처리
}
```

### 예시

```java
public void readFileWithTryResources(String fileName) {
    try (FileInputStream fis = new FileInputStream(fileName);
         BufferedReader reader = new BufferedReader(new InputStreamReader(fis))) {

        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }

    } catch (FileNotFoundException e) {
        System.out.println("파일을 찾을 수 없습니다: " + e.getMessage());
    } catch (IOException e) {
        System.out.println("파일 읽기 오류: " + e.getMessage());
    }
    // 리소스가 자동으로 닫힘
}
```

### 장점

1. 자동 리소스 관리: try 블록을 벗어날 때 자동으로 close() 메서드가 호출 (AutoCloseable 인터페이스)
2. 코드 간소화: finally 블록에서 수동으로 리소스를 닫는 코드가 불필요
3. 예외 처리 개선: 리소스 닫기 중 발생한 예외는 suppressed exception으로 처리되어 원본 예외가 가려지지 않음

## Suppressed Exception

주 예외가 발생한 상황에서 추가로 발생한 예외들을 "억제된(suppressed)" 예외로 분류하여 원본 예외와 함께 보존하는 기능

- 주 예외: 원래 발생한 핵심 예외
- Suppressed 예외: 주 예외 처리 과정에서 추가로 발생한 예외들

```java
try {
    // 주 예외 발생
    throw new RuntimeException("원본 문제");
} finally {
    // 정리 과정에서 추가 예외 발생
    throw new IOException("정리 중 문제"); // 이것이 suppressed 처리됨
}
```

### 전통적인 방식의 문제점

```java
public class TraditionalProblem {
    public static void problematicMethod() {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream("file.txt");
            // 원본 예외 발생
            throw new RuntimeException("데이터 처리 오류");

        } catch (FileNotFoundException e) {
            throw new RuntimeException("파일 없음", e);
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    // 이 예외가 원본 예외를 완전히 가려버림!
                    throw new RuntimeException("파일 닫기 실패");
                }
            }
        }
    }

    public static void main(String[] args) {
        try {
            problematicMethod();
        } catch (Exception e) {
            e.printStackTrace();
            // 출력: "파일 닫기 실패"만 보임
            // "데이터 처리 오류"는 완전히 사라짐!
        }
    }
}
```

### 장점과 특징

1. 완전한 오류 정보 보존
   1. 원본 문제와 부가적인 문제를 모두 확인 가능
   2. 디버깅 시 전체 상황 파악 용이
2. 컴파일러 차원의 자동 예외 관리
   1. 개발자가 별도 코드 작성 불필요
   2. 컴파일러가 자동으로 suppressed 처리 코드 생성
3. 우선순위 유지
   1. 주 예외가 항상 메인으로 유지됨
   2. 부가적 문제가 핵심 문제를 가리지 않음
4. 표준화된 접근
   1. 모든 try-with-resources에서 일관된 동작
   2. API를 통한 프로그래밍 방식 접근 가능
