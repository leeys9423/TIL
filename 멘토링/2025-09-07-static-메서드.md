# Java에서 static 메소드가 일반 메소드에 비해 가지는 장점과 단점은 무엇인가?

먼저 장점부터 보면, 가장 큰 장점은 **객체를 생성하지 않고**도 바로 클래스명으로 호출할 수 있다는 점입니다.

그래서 Math.max()나 String.valueOf() 같은 **유틸리티 성격**의 메서드들에 많이 사용됩니다. 또한 모든 인스턴스가 같은 메서드를 공유하기 때문에 메모리 효율성 면에서도 좋습니다.

단점을 보면, 우선 객체지향의 핵심 특성들인 **상속이나 다형성을 활용할 수 없습니다.**

그리고 인스턴스 변수에 접근할 수 없고, this 키워드도 사용할 수 없습니다. 또한 테스트할 때 모킹이 어렵고, 의존성 주입도 힘들어져서 단위 테스트 작성이 까다로워지는 문제가 있습니다.

메모리 관련해서는 static 메서드 자체보다는 static 변수를 부적절하게 사용했을 때 **GC 대상이 되지 않아서 메모리 누수가 발생할 수 있는 위험**이 있습니다.

결국 static 메서드는 상태를 갖지 않는 순수한 기능이나 유틸리티 메서드에는 적합하지만, 과도하게 사용하면 절차지향적인 코드가 될 수 있어서 적절한 균형이 중요하다고 생각합니다.

## static 메소드와 클래스 인스턴스 메소드의 메모리 관리 방식 차이는?

static 메서드와 인스턴스 메서드 모두 메서드 코드 자체는 **Method Area에 저장**됩니다. 차이점은 **호출 방식과 접근할 수 있는 데이터**에 있습니다.

static 메서드는 클래스가 로딩될 때 Method Area에 올라가서 클래스명으로 직접 호출할 수 있고, 클래스가 언로드되기 전까지 계속 메모리에 남아있습니다.

인스턴스 메서드도 Method Area에 있지만, 이 메서드를 실행하려면 힙 영역에 있는 객체 인스턴스를 통해야 합니다. 그래서 객체가 GC로 정리되면 해당 메서드에 더 이상 접근할 수 없게 됩니다.

정리하면, 메서드 자체의 저장 위치는 같지만, static은 클래스 레벨에서 관리되어 **객체 생성 없이 사용 가능**하고, 인스턴스 메서드는 반드시 **객체를 통해서만 접근**할 수 있다는 게 핵심 차이점입니다.

## static 메소드가 객체 지향 설계에 미치는 부정적인 영향은 무엇인가?

객체지향은 **객체들이 서로 협력해서 문제를 해결하는 패러다임**인데, static 메서드는 이런 철학과 맞지 않는 몇 가지 문제가 있습니다.

첫째, 캡슐화를 해칩니다. static 메서드는 **객체의 상태에 접근할 수 없어**서 데이터와 기능을 하나로 묶는 캡슐화 원칙에 위배됩니다.

둘째, **상속**과 **다형성**을 활용할 수 없습니다. static 메서드는 **오버라이딩이 불가능**하고, 인터페이스의 추상 메서드로도 선언할 수 없어서 객체지향의 핵심 특성들을 포기해야 합니다.

셋째, **의존성 주입이 어려워집니다**. static 메서드를 많이 사용하면 클래스 간의 **결합도가 높아지고**, 테스트할 때 모킹도 힘들어집니다.

결국 static 메서드를 과도하게 사용하면 객체 간의 협력보다는 단순한 **함수 호출 중심**의 절차지향적 코드가 되어버려서, 객체지향의 장점들인 유연성, 확장성, 재사용성을 잃게 됩니다.

## 왜 static 메소드를 과도하게 사용하는 것이 디자인 패턴에 위배될 수 있는가?

static 메서드를 과도하게 사용하면 **모듈 간의 유연한 결합**을 방해합니다.

예를 들어 Strategy 패턴 같은 경우, 알고리즘을 런타임에 교체할 수 있어야 하는데, static 메서드로는 이런 **동적인 교체가 불가능**합니다.

또한 대부분의 디자인 패턴들이 **의존성 역전**이나 **다형성**을 활용하는데, static은 이런 특성들을 사용할 수 없습니다.

결국 static을 남용하면 '변경에 유연하고 확장 가능한 설계'라는 디자인 패턴의 핵심 목적과 반대 방향으로 가게 됩니다."

## 용도에 따라 static 메소드와 인스턴스 메소드를 선택하는 기준은?

static 메서드를 사용하는 경우는

첫째, **상태에 의존하지 않는 순수 함수**일 때 입니다. Math.max()나 String.valueOf() 처럼 입력값만으로 결과가 결정되는 경우입니다.

둘째, **공통 유틸리티 기능**일 때 입니다. 날짜 포맷팅, 문자열 변환, 검증 로직 같이 여러 클래스에서 공통으로 사용되는 기능들입니다.

셋째, **팩토리 메서드로 객체 생성을 담당**할 때 입니다. 생성 로직이 복잡하거나 의미 있는 이름을 주고 싶을 때 사용합니다.

인스턴스 메서드를 사용하는 경우는

첫째, **객체의 상태를 사용하거나 변경**해야 할 때 입니다.

둘째, **다형성**이나 **상속**을 활용해야 할 때입니다. 오버라이딩이 필요하거나 인터페이스 구현이 필요한 경우입니다.

정리하자면, 특정 객체의 책임인가, 혹은 범용적인 도구인가를 판단하는 것입니다.
