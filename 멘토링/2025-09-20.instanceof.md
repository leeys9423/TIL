# instanceof

객체가 특정 클래스 또는 인터페이스의 인스턴스(객체)인지, 또는 해당 클래스를 상속받았는지 확인하는 연산자

## instanceof를 지양해야 하는 이유

`instanceof`를 남용하면 객체지향의 핵심인 **다형성**을 제대로 활용하지 못한다.

## 주요 문제점

### 1. 다형성 위반

- 타입별 분기 처리는 다형성의 본질과 반대
- 각 클래스가 자신의 행동을 정의하도록 하는 것이 객체지향의 기본

```java
// ❌ 문제가 있는 코드
public void processAnimal(Animal animal) {
    if (animal instanceof Dog) {
        ((Dog) animal).bark();
    } else if (animal instanceof Cat) {
        ((Cat) animal).meow();
    }
}

// ✅ 개선된 코드
public void processAnimal(Animal animal) {
    animal.makeSound(); // 각 클래스에서 오버라이드
}
```

### 2. 개방-폐쇄 원칙(OCP) 위반

- 새로운 타입 추가 시 기존 코드 수정 필요
- "확장에는 열려있고, 수정에는 닫혀있어야 한다"는 원칙 위배

```java
// 새로운 Bird 클래스 추가 시
// instanceof 사용 코드는 모두 수정 필요
public void processAnimal(Animal animal) {
    if (animal instanceof Dog) {
        ((Dog) animal).bark();
    } else if (animal instanceof Cat) {
        ((Cat) animal).meow();
    } else if (animal instanceof Bird) {  // 👈 추가 필요
        ((Bird) animal).chirp();
    }
}
```

### 3. 유지보수성 저하

- 타입 체크 로직이 여러 곳에 산재
- 비즈니스 로직 변경 시 수정 지점이 많아짐

### 올바른 접근법

```java
abstract class Animal {
    public abstract void makeSound();
}

class Dog extends Animal {
    @Override
    public void makeSound() { bark(); }
    private void bark() { System.out.println("Woof!"); }
}

class Cat extends Animal {
    @Override
    public void makeSound() { meow(); }
    private void meow() { System.out.println("Meow!"); }
}
```

### 적절한 사용 사례

```java
// ✅ 방어적 코딩
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof Person)) return false;
    Person other = (Person) obj;
    return this.id.equals(other.id);
}

// ✅ 예외 처리
try {
    // some operation
} catch (Exception e) {
    if (e instanceof SQLException) {
        // 특별한 DB 에러 처리
    }
}
```

### 결론

instanceof는 절차지향적 사고의 잔재입니다. "타입을 확인하고 → 분기하고 → 처리한다"는 순차적 사고입니다.

다형성은 객체지향적 사고의 핵심입니다. "객체에게 메시지를 보내면 → 객체가 알아서 처리한다"는 위임적 사고입니다.

좋은 객체지향 설계에서 런타임 타입 확인이 필요 없는 이유는, 애초에 "타입이 뭔지 몰라도 되도록" 인터페이스를 설계하기 때문입니다. 이것이 진정한 추상화의 힘이며, 코드를 더 유연하고 확장 가능하게 만드는 객체지향 프로그래밍의 본질입니다.