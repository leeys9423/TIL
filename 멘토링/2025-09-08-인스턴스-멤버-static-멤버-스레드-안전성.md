# Java에서 synchronized 키워드와의 차이점을 기반으로 인스턴스 멤버와 static 멤버의 스레드 안전성을 비교하라.

## synchronized 키워드 없이도 스레드 안전성을 확보할 수 있는 방법은 무엇인가?

첫째, **불변 객체를 활용**하는 것입니다. 불변 객체란 객체 내부의 상태가 변하지 않는 객체입니다. 그래서 여러 스레드가 동시에 접근해도 안전합니다.

둘째, **ThreadLocal**을 사용하는 방법입니다. 각 스레드마다 독립적인 변수 복사본을 가지게 해서 스레드 간 간섭을 막을 수 있습니다.

셋째, **Atomic 클래스를 활용**할 수 있습니다. AtomicInteger, AtomicReference 같은 클래스들은 CAS(Compare-And-Swap) 연산을 사용해서 lock 없이도 안전한 연산이 가능합니다.

> CAS (Compare-And-Swap)이란?
>
> "현재 값이 예상 값과 같으면 새로운 값으로 바꾸고, 다르면 실패"하는 원자적 연산
>
> 장점:
>
> - Lock-free: 블로킹 없이 동작하여 성능이 좋다
> - 데드락 없음: 락을 사용하지 않아서 데드락 위험이 없다.
>
> 단점:
>
> - ABA 문제: A -> B -> A로 변경되면 감지 못할 수 있음
> - 스핀락 효과: 경합이 심하면 CPU 사용량이 높아질 수 있음

넷째, **concurrent 패키지**의 자료구조들 입니다. 해당 패키지 안에 있는 클래스들은 내부적으로 스레드 안전성이 보장되어 있어서 별도 동기화가 필요 없습니다.

다섯째, **상태를 공유하지 않는 설계**입니다. 각 스레드가 독립적인 데이터로 작업하도록 설계하면 동기화 자체가 필요없습니다.

## static 멤버의 스레드 안전성을 강화하기 위한 설계 기법은?

첫째, **final 키워드로 불변성**을 보장합니다. 한 번 초기화되면 변경되지 않아서 여러 스레드가 안전하게 접근할 수 있습니다.

둘째, **volatile 키워드로 가시성을 보장**할 수 있습니다. 해당 변수를 읽을 때 **메인 메모리**에서 최신 값을 가져옵니다.

## 스레드 안전성이 중요한 경우와 그렇지 않은 경우의 구분은?

스레드 안전성이 중요한 경우:

첫째, **공유 자원에 쓰기 작업**이 있을 때 입니다. 여러 스레드가 동시에 변경하면 데이터 무결성이 깨질 수 있습니다.

둘째, **일관성이 중요한 읽기 작업**일 때도 문제가 됩니다. 예를 들어 계좌 조회 중에 다른 스레드가 잔액을 변경하면 불일치한 데이터를 읽을 수 있습니다.

셋째, **멀티스레드 환경**에서 실행되는 웹 애플리케이션, 서버 애플리케이션 같은 경우입니다.

넷째, **복합 연산**이 있을 때 입니다. count++ 처럼 읽기-계산-쓰기가 합쳐진 연산들입니다.

스레드 안전성이 덜 중요한 경우:

첫째, **단일 스레드 환경**이나 **독립적인 데이터로 작업**할 때 이미 스레드 안전성이 확보되어 있습니다.

둘째, **불변 객체**만 사용하는 경우에도 해당됩니다.

셋째, **지역 변수**나 **스택 영역의 데이터**는 스레드별로 독립적이라서 안전합니다.

## 스레드에 안전한 설계를 할 때 성능에 대한 고려사항은?

첫째, **동기화 오버헤드를 최소화**해야 합니다. synchronized나 Lock 사용 시 스레드들이 대기하게 되어 처리량이 떨어질 수 있어서, 꼭 필요한 부분만 동기화 범위로 잡는 것이 중요합니다.

둘째, **락 경합(Lock Contention)을 줄여야** 합니다. 여러 스레드가 같은 락을 두고 경쟁하면 성능이 급격히 떨어지는데, 락을 세분화하거나 락-프리 알고리즘을 사용하는 방법이 있습니다.

셋째, **적절한 동기화 기법**을 선택해야 합니다. **읽기 위주라면 ReadWriteLock**, 간단한 값 변경이라면 **Atomic** 클래스, 복잡한 로직이면 **synchronized** 같이 상황에 맞는 기법을 써야 해요.

넷째, **컨텍스트 스위칭 비용**을 고려해야 합니다. 너무 많은 스레드가 생성되면 CPU가 스레드 간 전환하는 데 시간을 많이 쓰게 되어서, 적절한 스레드 풀 크기를 설정하는 것이 중요합니다.

다섯째, 메모리 가시성 문제로 인한 성능 저하도 있습니다. volatile이나 동기화로 인해 CPU 캐시 무효화가 자주 발생하면 성능에 영향을 줄 수 있습니다.

## 스레드 안전성을 확보하기 위해 사용할 수 있는 Java의 기본 동기화 도구는?

첫째, synchronized 키워드입니다. 가장 기본적인 동기화 도구로 메서드나 블록 단위로 사용할 수 있습니다.

둘째, volatile 키워드입니다. 변수의 가시성을 보장해서 메모리 일관성 문제를 해결합니다.

셋째, wait()와 notify() 메서드들입니다. Object 클래스에 있는 기본 메서드들로 스레드 간 협력을 위해 사용됩니다.
