# JDBC에서 Interface와 Implementation의 차이점과 이 방식이 가지는 장점은 무엇인가?

JDBC는 인터페이스와 구현체가 분리된 구조로 설계되어 있습니다.

**JDBC 인터페이스**는 Java에서 제공하는 표준 API로, Connection, Statement, ResultSet 같은 인터페이스들이 java.sql 패키지에 정의되어 있습니다. 이는 '무엇을 할 것인가'만 정의하고 구체적인 구현은 없습니다.

**JDBC 구현체**는 각 데이터베이스 벤더가 이 인터페이스를 실제로 구현한 클래스들입니다. MySQL 드라이버, Oracle 드라이버 등이 이에 해당하며, 실제 데이터베이스와 통신하는 로직을 포함합니다.

**이 방식의 장점**은 데이터베이스 독립성입니다. 개발자는 표준화된 JDBC 인터페이스만 사용하면 되고, 데이터베이스를 변경할 때 코드 수정 없이 드라이버만 바꾸면 됩니다.

## JDBC 인터페이스 사용 시 데이터베이스 변경에 따른 코딩상의 이점은?

**첫 번째로**, 애플리케이션 코드 자체는 전혀 수정할 필요가 없습니다. Connection, Statement, ResultSet 같은 JDBC 인터페이스를 사용한 모든 비즈니스 로직은 그대로 유지됩니다.

**두 번째로**, 설정 정보만 변경하면 됩니다. 데이터베이스 URL과 드라이버 클래스명만 설정에서 바꿔주면 됩니다.

**세 번째로**, 컴파일이나 재배포가 필요 없습니다. 런타임에 새로운 드라이버 JAR 파일만 교체하면 바로 다른 데이터베이스를 사용할 수 있습니다.

## JDBC 드라이버의 구현체를 교체할 때의 유연함은 어떻게 확보되는가?

JDBC 드라이버 교체 시의 유연함은 인터페이스와 구현체가 분리된 설계 덕분에 확보됩니다.

구체적으로 보면, 개발자가 사용하는 Connection, Statement 같은 것들은 모두 인터페이스이고, 실제 구현은 각 데이터베이스 벤더의 드라이버가 담당합니다.

**DriverManager.getConnection()이** 핵심인데, 이 메서드가 URL을 보고 적절한 드라이버의 구현체를 찾아서 반환해줍니다. 그래서 개발자는 어떤 구현체가 반환되는지는 신경 쓸 필요가 없습니다.

## JDBC와 DBCP(DataSource)를 배치 환경에 적용할 때 고려해야 할 사항은?

배치 환경에서는 **대용량 데이터 처리와 장시간 실행**이라는 특성을 고려해야 합니다.

**첫 번째로, 커넥션 관리 측면**을 고려해야합니다. 장시간 커넥션을 점유하게 되므로 커넥션 풀이 고갈되거나 타임아웃 문제가 발생할 수 있습니다.

**두 번째로, DBCP 설정**에서 풀 사이즈를 배치 작업량에 맞게 조정해야하고, 커넥션 유효성 검증도 필요합니다.

세 번째로, 메모리 관리 측면에서 **대용량 ResultSet을 처리**할 때 **fetchSize를 적절히 설정**하거나, **청크 단위로 분할 처리**해서 메모리 부족을 방지해야 합니다.

**마지막으로** 배치 실행 중 DB 연결 장애 시 재연결 로직이나 트랜잭션 범위도 고려해야 합니다.

## 인터페이스 분리 원칙을 JDBC에 적용하는 구체적인 방법은?

클라이언트가 필요로 하는 기능별로 인터페이스를 나누는 것입니다.

첫 번째로, 하나의 큰 인터페이스 대신 역할별로 분리합니다. 예를 들어 데이터베이스 조회만 하는 클라이언트라면 조회 관련 메서드만 포함된 ReadOnlyRepository 인터페이스를 만들고, 업데이트가 필요한 클라이언트에게는 CommandRepository를 따로 제공하는 식입니다.

두 번째로, JDBC 자체도 이미 이 원칙을 잘 적용하고 있습니다. Statement는 기본적인 SQL 실행, PreparedStatement는 파라미터 바인딩, CallableStatement는 저장 프로시저 호출로 각각 다른 목적에 맞게 분리되어 있습니다.

세 번째로, 실무에서는 DAO 레이어에서 이를 구현합니다. 배치 처리 클라이언트에게는 BatchProcessor 인터페이스만 제공하고, 단순 조회 화면에는 QueryService만 제공하는 방식입니다.

이렇게 하면 각 클라이언트는 자신이 필요한 기능에만 의존하게 되어 코드가 더 안전하고 테스트하기 쉬워집니다.

## 실시간으로 JDBC 구현체를 변경해야 할 때 발생할 수 있는 문제점은?

첫 번째로, 기존 커넥션 처리 문제입니다. 이미 사용 중인 커넥션들이 있는데 갑자기 드라이버를 바꾸면 기존 커넥션들이 어떻게 될지 불분명하고, 진행 중인 트랜잭션이 롤백될 수 있습니다.

두 번째로, 커넥션 풀 상태 불일치 문제입니다. DBCP에 기존 드라이버의 커넥션들이 남아있는 상태에서 새로운 드라이버로 바뀌면 풀 내부가 혼재된 상태가 될 수 있습니다.

세 번째로, 클래스로더 문제입니다. 기존 드라이버 클래스가 이미 JVM에 로딩되어 있는 상태에서 새로운 드라이버를 동적으로 로딩하면 충돌이나 메모리 누수가 발생할 수 있습니다.

네 번째로, 데이터베이스별 차이점 문제입니다. MySQL에서 Oracle로 바뀐다면 SQL 문법 차이나 데이터 타입 차이로 런타임 에러가 발생할 수 있습니다.
