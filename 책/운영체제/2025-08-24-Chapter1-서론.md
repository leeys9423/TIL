# Chapter 1 서론

## **1.1 운영체제가 할 일 (What Operating Systems Do)**

**기본 개념:**

- **운영체제 (Operating System)** - 사용자와 하드웨어 사이의 중개자
  → 사용자가 "파일 저장"을 누르면, 실제 하드디스크에 저장하는 복잡한 과정을 대신 처리해줌
- **컴퓨터 시스템 구성요소** - 하드웨어, 운영체제, 응용프로그램, 사용자
  → 4층 구조: 사용자 → 응용프로그램(워드, 게임) → 운영체제 → 하드웨어
- **사용자 인터페이스** - 사용자가 시스템과 상호작용하는 방법
  → GUI(윈도우, 마우스), CLI(명령어 창), 터치스크린 등

**관점별 정의:**

- **사용자 관점** - 편의성, 사용 용이성, 성능
  → "컴퓨터 쓰기 편하게 해줘, 빠르게 해줘"
- **시스템 관점** - 자원 할당자, 제어 프로그램
  → "CPU는 A프로그램, 메모리는 B프로그램에게 줄게"
- **커널 (Kernel)** - 항상 실행되는 핵심 프로그램
  → 컴퓨터 켜져 있는 동안 계속 돌아가는 OS의 핵심 부분

## **1.2 컴퓨터 시스템의 구성 (Computer-System Organization)**

**하드웨어 구성:**

- **CPU** - 명령어 실행 장치
  → 실제로 계산하고 판단하는 "뇌" 역할
- **주메모리 (Main Memory)** - 프로그램과 데이터가 저장되는 곳
  → RAM, 전원 꺼지면 내용 사라짐, 빠르지만 용량 제한적
- **저장장치 (Storage)** - 데이터를 영구 보관
  → 하드디스크, SSD, 전원 꺼져도 내용 유지, 느리지만 대용량
- **I/O 장치** - 입출력 담당
  → 키보드(입력), 모니터(출력), 마우스, 프린터 등
- **시스템 버스** - 구성요소들을 연결
  → 도로망처럼 데이터가 오가는 통로

**시스템 동작:**

- **부트스트랩 프로그램** - 시스템 시작 프로그램
  → 컴퓨터 켤 때 맨 처음 실행되는 프로그램, 운영체제를 메모리에 올림
- **인터럽트 (Interrupt)** - 하드웨어의 CPU 알림 메커니즘
  → "키보드 눌렀어요!", "디스크 읽기 완료했어요!" 같은 알림
- **폴링 (Polling)** - CPU가 직접 상태를 확인
  → CPU가 "혹시 일 있어?" 하고 계속 물어보는 방식
- **DMA (Direct Memory Access)** - CPU 개입 없이 메모리 접근
  → 디스크에서 메모리로 데이터 복사할 때 CPU가 다른 일 할 수 있게 해줌

## **1.3 컴퓨터 시스템 구조 (Computer-System Architecture)**

**프로세서 분류:**

- **단일 프로세서 시스템** - CPU 하나
  → 예전 컴퓨터들, 한 번에 한 가지 일만 처리
- **다중 프로세서 시스템** - 여러 CPU 사용
  → 여러 일을 동시에 처리 가능, 성능 향상
- **대칭 다중처리 (SMP)** - 모든 프로세서가 동등
  → 모든 CPU가 똑같은 권한, 아무 CPU나 아무 일이나 처리
- **비대칭 다중처리** - 주-부 프로세서 구조
  → 메인 CPU가 있고 보조 CPU들이 특정 업무만 담당

**다중 코어:**

- **다중 코어 시스템** - 하나의 칩에 여러 CPU 코어
  → 듀얼코어, 쿼드코어, 옥타코어 등
- **블레이드 서버** - 여러 프로세서 보드를 하나의 섀시에 장착
  → 서버실에서 공간 절약하면서 성능 높이는 방식

**클러스터:**

- **클러스터 시스템** - 네트워크로 연결된 여러 시스템
  → 여러 컴퓨터를 묶어서 하나처럼 사용
- **고가용성 (High Availability)** - 시스템 장애 대응
  → 하나 고장나도 다른 것이 대신 처리해서 서비스 중단 없음

## **1.4 운영체제의 작동 (Operating-System Operations)**

**다중 프로그래밍:**

- **다중프로그래밍** - 여러 프로그램을 메모리에 동시 적재
  → 워드, 브라우저, 음악프로그램을 동시에 실행
- **작업 풀 (Job Pool)** - 실행 대기 중인 작업들
  → 대기줄에 서 있는 프로그램들
- **CPU 스케줄링** - 다음 실행할 프로그램 선택
  → "이번엔 워드 실행할 차례, 그 다음은 브라우저"

**시분할:**

- **시분할 (Time Sharing)** - CPU 시간을 나누어 사용
  → CPU를 아주 짧은 시간(밀리초)씩 나눠서 번갈아 실행
- **대화형 시스템** - 사용자와 실시간 상호작용
  → 키보드 입력하면 즉시 반응하는 시스템
- **응답 시간** - 요청부터 응답까지의 시간
  → 마우스 클릭하면 얼마나 빨리 반응하는지

**이중 모드 작동:**

- **사용자 모드** - 일반 프로그램 실행
  → 제한된 권한, 안전한 명령어만 실행 가능
- **커널 모드** - 운영체제 실행, 특권 명령 가능
  → 모든 권한, 하드웨어 직접 제어 가능
- **모드 비트** - 현재 모드 구분
  → 하드웨어가 "지금 어떤 모드인지" 기억하는 스위치
- **시스템 콜** - 사용자 → 커널 모드 전환
  → "운영체제야, 파일 저장 좀 도와줘" 하고 요청하는 방법

**보호 기능:**

- **타이머** - 프로그램 실행 시간 제한
  → 한 프로그램이 CPU 독점 못하게 강제로 시간 제한
- **특권 명령** - 커널 모드에서만 실행 가능한 명령
  → 시스템 종료, 하드웨어 직접 제어 등 위험한 명령들

## **1.5 자원 관리 (Resource Management)**

**프로세스 관리:**

- **프로세스** - 실행 중인 프로그램
  → 메모리에 올라와서 실제로 돌아가고 있는 프로그램
- **프로그램** - 저장장치에 저장된 명령어들
  → 하드디스크에 저장된 실행파일(.exe)
- **프로세스 생성/종료** - 프로세스 생명주기 관리
  → 프로그램 실행할 때 생성, 종료할 때 정리
- **프로세스 동기화** - 프로세스 간 협력
  → 여러 프로그램이 동시에 같은 파일 접근할 때 충돌 방지

**메모리 관리:**

- **메모리 할당/해제** - 프로그램에게 메모리 공간 제공
  → "A프로그램은 100MB, B프로그램은 200MB 사용해"
- **메모리 보호** - 다른 프로세스 메모리 침범 방지
  → A프로그램이 B프로그램 메모리 건드리지 못하게 보호
- **가상 메모리** - 물리 메모리보다 큰 주소 공간 제공
  → RAM 4GB인데 8GB 프로그램도 실행 가능하게 해주는 기술

**파일 시스템 관리:**

- **파일** - 논리적 저장 단위
  → 문서, 사진, 동영상 등 데이터를 묶어놓은 단위
- **디렉토리** - 파일들의 조직화
  → 폴더, 파일들을 정리해서 찾기 쉽게 만듦
- **접근 제어** - 파일 보안 및 권한
  → "이 파일은 관리자만 삭제 가능", "읽기만 허용" 등

**대용량 저장장치 관리:**

- **디스크 스케줄링** - 디스크 접근 순서 최적화
  → 헤드 움직임을 최소화해서 빠르게 데이터 읽기
- **백업** - 데이터 보호
  → 중요한 데이터 복사본 만들어서 분실 방지
- **저장장치 할당** - 공간 관리
  → "A파일은 여기, B파일은 저기" 하고 공간 배치

**I/O 시스템:**

- **장치 드라이버** - 특정 하드웨어 제어 프로그램
  → 그래픽카드, 프린터 등 각 장치별로 제어하는 소프트웨어
- **버퍼링** - 속도 차이 극복
  → 빠른 CPU와 느린 디스크 사이에 임시 저장공간 두기
- **캐싱** - 자주 사용하는 데이터 임시 저장
  → 한 번 읽은 데이터를 빠른 곳에 저장해뒀다가 재사용

## **1.6 보안과 보호 (Security and Protection)**

**보호 (Protection):**

- **접근 제어** - 시스템 자원에 대한 접근 통제
  → "이 파일은 소유자만 읽을 수 있어", "이 메모리는 다른 프로그램이 접근 불가"
- **사용자 식별** - 사용자 인증 메커니즘
  → 로그인할 때 아이디/패스워드로 "누구인지" 확인
- **권한 부여** - 사용자별 권한 설정
  → 관리자는 모든 권한, 일반 사용자는 제한된 권한
- **특권 에스컬레이션** - 권한 상승
  → 일반 사용자가 관리자 권한이 필요한 작업 수행할 때

**보안 (Security):**

- **인증 (Authentication)** - "당신이 누구인가?"
  → 지문인식, 얼굴인식, 2단계 인증 등
- **인가 (Authorization)** - "당신이 이걸 할 수 있는가?"
  → 인증 후에 "이 작업을 수행할 권한이 있는지" 확인
- **멀웨어 (Malware)** - 악성 소프트웨어
  → 바이러스, 웜, 트로이목마, 랜섬웨어 등
- **침입 탐지** - 비정상적 접근 감지
  → "누군가 시스템에 무단 침입하려고 하네?"

## **1.7 가상화 (Virtualization)**

**가상화 개념:**

- **가상화 (Virtualization)** - 하나의 컴퓨터에서 여러 운영체제 실행
  → VMware, VirtualBox로 윈도우에서 리눅스 돌리기
- **하이퍼바이저 (Hypervisor)** - 가상머신 관리자
  → 여러 운영체제들을 관리하고 하드웨어 자원 배분
- **게스트 운영체제** - 가상머신 위에서 실행되는 OS
  → 가상머신 안에서 돌아가는 윈도우, 리눅스 등
- **호스트 운영체제** - 실제 하드웨어에서 실행되는 OS
  → 물리적 컴퓨터에 설치된 기본 운영체제

**가상화 장점:**

- **자원 효율성** - 하나의 서버로 여러 서비스 운영
  → 서버 한 대에 웹서버, DB서버, 메일서버 각각 다른 OS로 실행
- **격리성** - 가상머신끼리 서로 독립적
  → 하나 가상머신이 망가져도 다른 것들은 안전
- **이식성** - 가상머신을 다른 하드웨어로 쉽게 이동
  → 서버 바꿀 때 가상머신 파일만 복사하면 끝

## **1.8 분산 시스템 (Distributed Systems)**

**분산 시스템 개념:**

- **분산 시스템** - 네트워크로 연결된 여러 컴퓨터가 협력
  → 구글 검색은 전 세계 수만 대 서버가 함께 처리
- **네트워크 운영체제** - 네트워크를 인식하는 OS
  → 다른 컴퓨터의 파일이나 프린터를 내 컴퓨터처럼 사용
- **분산 운영체제** - 여러 컴퓨터를 하나처럼 보이게 함
  → 사용자는 여러 컴퓨터인지 모르고 하나의 시스템으로 인식

**분산 시스템 특성:**

- **투명성** - 분산되어 있다는 것을 사용자가 못 느끼게
  → 클라우드 저장소 쓸 때 어느 서버에 저장되는지 모르지만 상관없음
- **확장성 (Scalability)** - 시스템 규모를 쉽게 늘릴 수 있음
  → 사용자 늘어나면 서버 추가로 대응
- **신뢰성** - 일부 컴퓨터가 고장나도 전체 시스템은 정상 동작
  → 페이스북 서버 몇 대 고장나도 서비스는 계속됨

**분산 시스템 유형:**

- **클라이언트-서버 시스템** - 서비스 제공자와 사용자 구분
  → 웹 브라우저(클라이언트) ↔ 웹 서버(서버)
- **피어-투-피어 (P2P)** - 모든 노드가 동등한 관계
  → 토렌트, 블록체인처럼 중앙 서버 없이 서로 연결

## **1.9 커널 자료구조 (Kernel Data Structures)**

**기본 자료구조:**

- **리스트 (Lists)** - 데이터를 순서대로 연결
  → 실행 중인 프로세스들을 링크드 리스트로 관리
- **스택 (Stacks)** - 후입선출(LIFO) 구조
  → 함수 호출할 때 리턴 주소 저장
- **큐 (Queues)** - 선입선출(FIFO) 구조
  → 프린터 작업 대기열, CPU 스케줄링 대기열
- **트리 (Trees)** - 계층적 구조
  → 파일 시스템의 디렉토리 구조, 프로세스 부모-자식 관계
- **해시 함수와 맵** - 빠른 검색을 위한 구조
  → 파일 이름으로 빠르게 파일 찾기

**커널에서의 활용:**

- **프로세스 관리** - 프로세스 정보를 자료구조로 관리
  → 각 프로세스의 상태, 메모리 사용량, 우선순위 등
- **메모리 관리** - 사용 가능한 메모리 블록들을 리스트로 관리
  → "여기 100KB 비어있음", "저기 50KB 사용 중" 등

## **1.10 계산 환경 (Computing Environments)**

**전통적 컴퓨팅:**

- **데스크톱 컴퓨팅** - 개인용 컴퓨터
  → 한 사람이 한 대의 컴퓨터 사용
- **포털** - 다양한 서비스 통합 제공
  → 네이버, 다음처럼 메일, 뉴스, 검색 등을 한 곳에서

**모바일 컴퓨팅:**

- **모바일 장치** - 스마트폰, 태블릿
  → 배터리 수명, 터치 인터페이스, 무선 연결 고려
- **모바일 운영체제** - iOS, Android
  → 전력 효율성, 터치 최적화, 앱 스토어 생태계

**클라이언트-서버 컴퓨팅:**

- **씬 클라이언트** - 최소한의 기능만 가진 단말
  → 웹 브라우저만 있고 모든 작업은 서버에서
- **팻 클라이언트** - 독립적 처리 능력을 가진 클라이언트
  → 로컬에서도 많은 작업 처리 가능

**피어-투-피어 컴퓨팅:**

- **분산 처리** - 여러 컴퓨터가 작업을 나눠서 처리
  → SETI@home처럼 일반 PC들이 우주 신호 분석
- **파일 공유** - 중앙 서버 없이 직접 파일 교환
  → BitTorrent, 블록체인

**클라우드 컴퓨팅:**

- **SaaS (Software as a Service)** - 소프트웨어를 서비스로
  → 구글 독스, Office 365처럼 웹에서 바로 사용
- **PaaS (Platform as a Service)** - 개발 플랫폼 제공
  → 개발자가 코드만 올리면 실행환경은 제공
- **IaaS (Infrastructure as a Service)** - 하드웨어 인프라 제공
  → AWS EC2처럼 가상 서버 임대

**실시간 임베디드 시스템:**

- **실시간 시스템** - 정해진 시간 내 반드시 응답
  → 자동차 에어백, 심장박동기처럼 늦으면 생명 위험
- **임베디드 시스템** - 특정 기능만 수행하는 컴퓨터
  → 세탁기, 전자레인지 안의 마이크로프로세서
