# 일관성 있는 협력

## 핵심 개념

**일관성 있는 협력**이란 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용하는 것을 의미합니다. 이는 코드의 이해가능성과 수정 용이성을 높여줍니다.

### 핸드폰 과금 시스템 예제

책에서는 핸드폰 과금 시스템을 통해 일관성 있는 협력의 중요성을 설명합니다.

**기본 정책들**

- 일반 요금제: 단위 시간당 요금 부과
- 심야 할인 요금제: 밤 시간대 할인
- 요일별 할인 요금제: 특정 요일 할인
- 구간별 요금제: 통화 시간 구간별 차등 요금

### 설계의 일관성을 위한 지침

#### 1. 변하는 개념을 변하지 않는 개념으로부터 분리하라

**변하지 않는 부분**: 협력의 흐름과 구조
**변하는 부분**: 구체적인 요금 계산 로직

```java
public abstract class Phone {
    private List<Call> calls = new ArrayList<>();

    public Money calculateFee() {
        Money result = Money.ZERO;
        for(Call call : calls) {
            result = result.plus(calculateCallFee(call));
        }
        return result;
    }

    abstract protected Money calculateCallFee(Call call);
}
```

#### 2. 변하는 개념을 캡슐화하라

각 요금제별로 구체적인 계산 로직을 캡슐화:

```java
public class RegularPhone extends Phone {
    private Money amount;
    private Duration seconds;

    @Override
    protected Money calculateCallFee(Call call) {
        return amount.times(call.getDuration().getSeconds() / seconds.getSeconds());
    }
}
```

### 협력 패턴의 일관성

#### Template Method 패턴 적용

모든 요금제 클래스가 동일한 협력 구조를 따름:

1. 전체 통화 목록 순회
2. 각 통화에 대해 요금 계산
3. 계산된 요금들을 합산

이 구조는 변하지 않으며, 구체적인 계산 방식만 서브클래스에서 구현합니다.

### 다형성을 통한 일관성

**다형성의 장점**

- 클라이언트 코드가 구체적인 클래스에 의존하지 않음
- 새로운 요금제 추가 시 기존 코드 변경 불필요
- 런타임에 적절한 메서드가 선택됨

```java
Phone phone = new NightlyDiscountPhone(...);
Money fee = phone.calculateFee(); // 다형성을 통한 호출
```

### 추가 요금 정책의 일관성

**부가 정책들**

- 세금 정책
- 기본 요금 정책
- 할인 정책

이들도 동일한 협력 패턴을 따르도록 설계:

```java
public abstract class AdditionalRatePolicy implements RatePolicy {
    private RatePolicy next;

    public Money calculateFee(Phone phone) {
        Money fee = next.calculateFee(phone);
        return afterCalculated(fee);
    }

    abstract protected Money afterCalculated(Money fee);
}
```

### 일관성의 이점

#### 1. 코드 이해 용이성

- 한 번 익힌 협력 패턴이 다른 곳에서도 반복됨
- 새로운 기능을 이해하는 데 필요한 인지적 부담 감소

#### 2. 코드 수정 용이성

- 일관된 구조로 인해 변경 지점 예측 가능
- 동일한 수정 패턴 적용 가능

#### 3. 코드 재사용성

- 공통된 협력 구조 추출 가능
- 새로운 기능 추가 시 기존 패턴 재활용

### 설계 원칙과의 연관성

#### 개방-폐쇄 원칙(OCP)

- 새로운 요금제 추가 시 기존 코드 수정 없이 확장 가능

#### 의존성 역전 원칙(DIP)

- 추상화에 의존하여 구체적인 구현의 변경에 영향받지 않음

#### 리스코프 치환 원칙(LSP)

- 모든 요금제 클래스가 Phone 타입으로 치환 가능

### 결론

일관성 있는 협력은 변하지 않는 부분과 변하는 부분을 분리하고, 변하는 부분을 적절히 캡슐화함으로써 달성할 수 있습니다. 이를 통해 이해하기 쉽고, 수정하기 쉬우며, 확장 가능한 설계를 만들 수 있습니다.

**핵심은 유사한 기능에는 유사한 협력 패턴을 적용하여 코드 전체의 일관성을 유지하는 것입니다.**
