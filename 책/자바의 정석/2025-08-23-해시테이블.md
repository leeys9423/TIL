# 해시테이블 구조 정리

## 1. 해시테이블의 기본 개념

### Hash Function (해시 함수)

- **역할**: 임의 크기의 데이터를 고정된 크기 값으로 변환
- **목적**: 데이터를 배열의 인덱스로 매핑
- **예시**: `"apple".hashCode() % 배열크기 = 인덱스`

### Hash Table (해시 테이블)

- **정의**: 해시 함수를 사용하여 키-값 쌍을 저장하는 자료구조
- **장점**: 평균 O(1) 시간복잡도로 검색, 삽입, 삭제
- **단점**: 해시 충돌 가능성, 메모리 사용량 증가

## 2. 버킷(Bucket) 구조

### 버킷이란?

- 해시 테이블의 각 **배열 요소**
- 하나 이상의 키-값 쌍을 저장할 수 있는 **저장 공간**
- 해시 충돌 시 여러 데이터가 같은 버킷에 저장됨

### 해시 충돌 (Hash Collision)

```
예시: 배열 크기 7인 해시 테이블

"cat" → hash = 312 → 312 % 7 = 4
"fox" → hash = 333 → 333 % 7 = 4  ← 충돌!
"bat" → hash = 311 → 311 % 7 = 4  ← 또 충돌!

결과: 버킷[4]에 3개 데이터가 모두 저장됨
```

### 충돌 해결: 체이닝 (Chaining)

```
버킷 배열 구조:

[0] → null
[1] → null
[2] → ["owl"]
[3] → null
[4] → ["cat"] → ["fox"] → ["bat"]  ← 연결리스트
[5] → ["pig"] → ["rat"]
[6] → ["dog"]
```

## 3. 메모리 구조 (Java HashMap 기준)

### 전체 메모리 레이아웃

```
힙 메모리 구조:

┌─────────────────────────────────────┐
│          버킷 배열 (연속 메모리)         │
│  [0] [1] [2] [3] [4] [5] [6] ...    │
│   ↓   ↓   ↓   ↓   ↓   ↓   ↓         │
└─────────────────────────────────────┘
    │   │   │   │   │   │   │
    │   │   │   │   │   │   └→ 주소4200 (Node)
    │   │   │   │   │   └────→ 주소7800 (Node)
    │   │   │   │   └────────→ 주소2500 (Node)
    │   │   │   └────────────→ null
    │   │   └────────────────→ 주소3100 (Node)
    │   └────────────────────→ null
    └────────────────────────→ null

각 Node 객체들은 힙의 여러 위치에 흩어져 있음
```

### Node 객체의 내부 구조

```java
class Node<K,V> {
    final int hash;        // 해시값 저장
    final K key;          // 키 객체의 참조
    V value;              // 값 객체의 참조
    Node<K,V> next;       // 다음 노드의 참조 (충돌 시)
}
```

### 실제 메모리 배치 예시

```
메모리 주소별 객체 배치:

[1000번지] 버킷 배열
├─ table[0] = null
├─ table[1] = null
├─ table[4] = 2500  ← Node 주소
└─ table[6] = 4200  ← Node 주소

[2500번지] Node 객체 #1
├─ hash: 4
├─ key: 3000 (String "cat"의 주소)
├─ value: 6000 (AnimalInfo의 주소)
└─ next: 7800 (다음 Node 주소)

[3000번지] String "cat" 객체

[4200번지] Node 객체 #2
├─ hash: 6
├─ key: 5000 (String "dog"의 주소)
├─ value: 8000 (AnimalInfo의 주소)
└─ next: null

[5000번지] String "dog" 객체
[6000번지] AnimalInfo(고양이) 객체
[7800번지] Node 객체 #3 (충돌된 다른 키)
[8000번지] AnimalInfo(개) 객체
```

## 4. 검색 과정 상세 분석

### map.get("cat") 실행 시:

1. **해시 계산**: `"cat".hashCode() % table.length = 4`

2. **버킷 접근**: `table[4]` → 주소 2500 반환

3. **연결리스트 탐색**:

   - 주소 2500의 Node에서 `key.equals("cat")` 비교
   - 일치하면 해당 Node의 value 반환
   - 불일치하면 `next` 따라서 다음 Node로 이동

4. **값 반환**: 찾은 Node의 value(주소 6000) → AnimalInfo 객체 반환

## 5. 메모리 특성 비교

### ArrayList vs HashMap

**ArrayList (연속 메모리)**:

```
[apple][banana][cherry][dog] ← 연속 배치
 [0]    [1]     [2]    [3]   ← 인덱스 순서
```

- **장점**: 캐시 친화적, 메모리 효율적
- **단점**: 중간 삽입/삭제 시 O(n)

**HashMap (비연속 메모리)**:

```
버킷배열: [ptr1][null][ptr2][ptr3]...
         ↓            ↓     ↓
      Node1 → Node2  Node3  Node4
```

- **장점**: O(1) 검색, 동적 크기 조절
- **단점**: 메모리 점프 많음, 포인터 오버헤드

## 6. 성능 특성

### 시간 복잡도

- **평균**: O(1) - 검색, 삽입, 삭제
- **최악**: O(n) - 모든 키가 같은 버킷에 몰린 경우

### 공간 복잡도

- **기본**: O(n)
- **추가**: 각 Node마다 포인터 오버헤드
- **로드 팩터**: 일반적으로 75% 유지 (성능과 메모리의 균형)

### 해시 충돌이 성능에 미치는 영향

```
좋은 해시 함수 (균등 분산):
[1개] [1개] [1개] [1개] [1개] ← 각 버킷에 균등 분산
 O(1)  O(1)  O(1)  O(1)  O(1) ← 모두 상수 시간

나쁜 해시 함수 (한쪽 몰림):
[5개] [  ] [  ] [  ] [  ] ← 한 버킷에 몰림
 O(5)                     ← 선형 탐색 필요
```

## 7. 실제 사용 시 고려사항

### 좋은 해시 함수 조건

1. **균등 분산**: 데이터를 버킷에 고르게 분산
2. **결정적**: 같은 입력에 항상 같은 출력
3. **효율적**: 해시 계산이 빠름

### HashMap 사용 시 주의점

1. **키 객체**는 `hashCode()`와 `equals()` 모두 구현 필요
2. **가변 객체**를 키로 사용 시 주의 (해시값 변경 가능)
3. **로드 팩터** 조절로 성능 최적화 가능

---

**핵심 요약**: 해시테이블은 해시 함수를 통해 데이터를 버킷 배열에 매핑하고, 각 버킷은 연결리스트로 충돌을 해결하며, 실제 메모리에서는 참조를 통한 비연속적 구조를 가진다.
