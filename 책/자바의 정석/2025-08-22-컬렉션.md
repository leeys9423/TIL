# 컬렉션 프레임웍(Collections Framework)

## 1. 컬렉션 프레임웍 개요

### 1.1 컬렉션 프레임웍이란?

- 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합
- 데이터 그룹을 저장하는 클래스들을 표준화한 설계

### 1.2 컬렉션 프레임웍의 핵심 인터페이스

```
Collection
├── List (순서O, 중복O)
│   ├── ArrayList
│   ├── LinkedList
│   └── Vector
├── Set (순서X, 중복X)
│   ├── HashSet
│   ├── LinkedHashSet
│   └── TreeSet
└── Map (키-값 쌍, 키는 중복X)
    ├── HashMap
    ├── LinkedHashMap
    ├── TreeMap
    └── Hashtable
```

## 2. List 인터페이스

### 2.1 List 특징

- 순서가 있는 데이터의 집합
- 데이터의 중복을 허용

### 2.2 ArrayList

```java
ArrayList<String> list = new ArrayList<>();
list.add("apple");
list.add("banana");
list.add(1, "orange"); // 인덱스 1에 삽입

String item = list.get(0); // "apple"
list.remove(1); // "orange" 제거
list.set(0, "grape"); // "apple"을 "grape"로 변경
```

**특징:**

- 배열 기반으로 데이터 저장
- 데이터 조회가 빠름 (인덱스 접근)
- 중간 삽입/삭제 시 성능 저하

### 2.3 LinkedList

```java
LinkedList<String> list = new LinkedList<>();
list.add("first");
list.addFirst("zero");
list.addLast("last");
list.removeFirst();
```

**특징:**

- 이중 연결 리스트로 구현
- 삽입/삭제가 빠름
- 순차적 접근만 가능 (인덱스 접근 시 성능 저하)

### 2.4 Vector

- ArrayList와 유사하지만 동기화됨 (thread-safe)
- 성능상 ArrayList 사용 권장

## 3. Set 인터페이스

### 3.1 Set 특징

- 중복을 허용하지 않는 데이터의 집합
- 순서가 유지되지 않음 (LinkedHashSet 제외)

### 3.2 HashSet

```java
HashSet<String> set = new HashSet<>();
set.add("apple");
set.add("banana");
set.add("apple"); // 중복 - 추가되지 않음

System.out.println(set.size()); // 2
System.out.println(set.contains("apple")); // true
```

**특징:**

- 해싱을 이용해 구현
- 가장 빠른 임의 접근 속도
- 순서를 예측할 수 없음

### 3.3 LinkedHashSet

```java
LinkedHashSet<String> set = new LinkedHashSet<>();
set.add("third");
set.add("first");
set.add("second");
// 입력 순서가 유지됨
```

### 3.4 TreeSet

```java
TreeSet<Integer> set = new TreeSet<>();
set.add(7);
set.add(4);
set.add(9);
set.add(1);

System.out.println(set); // [1, 4, 7, 9] - 정렬됨
System.out.println(set.first()); // 1
System.out.println(set.last()); // 9
```

**특징:**

- 이진 검색 트리로 구현
- 자동으로 정렬됨
- 검색과 정렬에 유리

## 4. Map 인터페이스

### 4.1 Map 특징

- 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합
- 키는 중복을 허용하지 않고, 값은 중복 허용

### 4.2 HashMap

```java
HashMap<String, Integer> map = new HashMap<>();
map.put("apple", 1000);
map.put("banana", 2000);
map.put("orange", 1500);

Integer price = map.get("apple"); // 1000
map.remove("banana");

// 키의 존재 여부 확인
if (map.containsKey("apple")) {
    System.out.println("사과 가격: " + map.get("apple"));
}
```

**반복 처리:**

```java
// 키 집합으로 반복
for (String key : map.keySet()) {
    System.out.println(key + " : " + map.get(key));
}

// entrySet으로 반복 (더 효율적)
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " : " + entry.getValue());
}
```

### 4.3 LinkedHashMap

```java
LinkedHashMap<String, Integer> map = new LinkedHashMap<>();
// 입력 순서가 유지됨
```

### 4.4 TreeMap

```java
TreeMap<String, Integer> map = new TreeMap<>();
map.put("c", 3);
map.put("a", 1);
map.put("b", 2);

System.out.println(map); // {a=1, b=2, c=3} - 키로 정렬됨
```

### 4.5 Hashtable

- HashMap과 유사하지만 동기화됨
- null 값과 null 키를 허용하지 않음

## 5. Collections 클래스

### 5.1 컬렉션의 동기화

```java
List<String> list = new ArrayList<>();
List<String> syncList = Collections.synchronizedList(list);

Map<String, String> map = new HashMap<>();
Map<String, String> syncMap = Collections.synchronizedMap(map);
```

### 5.2 변경불가 컬렉션

```java
List<String> list = new ArrayList<>();
list.add("apple");
List<String> unmodifiableList = Collections.unmodifiableList(list);
// unmodifiableList.add("banana"); // UnsupportedOperationException
```

### 5.3 싱글톤 컬렉션

```java
List<String> singletonList = Collections.singletonList("only");
Set<String> singletonSet = Collections.singleton("only");
Map<String, String> singletonMap = Collections.singletonMap("key", "value");
```

### 5.4 정렬

```java
List<String> list = Arrays.asList("banana", "apple", "cherry");

Collections.sort(list); // 오름차순 정렬
Collections.reverse(list); // 순서 뒤집기
Collections.shuffle(list); // 무작위 섞기

// 내림차순 정렬
Collections.sort(list, Collections.reverseOrder());
```

## 6. Comparator와 Comparable

### 6.1 Comparable 인터페이스

```java
class Student implements Comparable<Student> {
    String name;
    int score;

    @Override
    public int compareTo(Student s) {
        return Integer.compare(this.score, s.score); // 점수로 비교
    }
}
```

### 6.2 Comparator 인터페이스

```java
List<Student> students = new ArrayList<>();

// 이름으로 정렬
Collections.sort(students, new Comparator<Student>() {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name);
    }
});

// 람다식 사용 (Java 8+)
Collections.sort(students, (s1, s2) -> s1.name.compareTo(s2.name));

// Comparator 메서드 사용 (Java 8+)
students.sort(Comparator.comparing(s -> s.name));
students.sort(Comparator.comparingInt(s -> s.score).reversed());
```

## 7. 컬렉션 선택 가이드

### 7.1 List 구현체 선택

- **ArrayList**: 인덱스를 이용한 조회가 많은 경우
- **LinkedList**: 삽입/삭제가 빈번한 경우
- **Vector**: 멀티스레드 환경에서 안전성이 필요한 경우

### 7.2 Set 구현체 선택

- **HashSet**: 빠른 검색이 필요하고 순서가 중요하지 않은 경우
- **LinkedHashSet**: 입력 순서를 유지해야 하는 경우
- **TreeSet**: 정렬된 순서를 유지해야 하는 경우

### 7.3 Map 구현체 선택

- **HashMap**: 빠른 검색이 필요하고 순서가 중요하지 않은 경우
- **LinkedHashMap**: 입력 순서를 유지해야 하는 경우
- **TreeMap**: 키의 정렬 순서를 유지해야 하는 경우

## 8. 제네릭스와의 관계

### 8.1 타입 안전성

```java
// 제네릭스 사용 전 (비권장)
List list = new ArrayList();
list.add("String");
list.add(123); // 런타임 오류 가능성

// 제네릭스 사용 후 (권장)
List<String> list = new ArrayList<String>();
list.add("String");
// list.add(123); // 컴파일 오류
```

### 8.2 다이아몬드 연산자 (Java 7+)

```java
List<String> list = new ArrayList<>(); // 타입 추론
Map<String, List<Integer>> map = new HashMap<>();
```
