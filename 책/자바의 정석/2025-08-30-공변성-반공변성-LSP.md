# 공변성, 반공변성, LSP

## 공변성

기본 타입이 다른 타입으로 대체될 때, 파생 타입도 함께 대체될 수 있는 경우를 말함("상위 타입을 하위 타입으로 대체해도 원래 타입을 사용하는 곳에서 문제없이 작동한다"라는 의미)

## 반공변성

공변성과 반대로, 기본 타입이 다른 타입으로 대체될 때, 파생 타입은 반대 방향으로 대체될 수 있는 경우를 말함(하위 타입을 상위 타입으로 대체해도 원래 타입을 사용하는 곳에서 문제 없이 작동한다)

**제네릭**에서 공변성과 반공변성이 중요한 이유:

- 제네릭 타입을 더 유연하게 사용할 수 있도록 하여 코드의 재사용성을 높여줌.
- 라이브러리나 프레임워크를 설계할 때, 개발자가 예상치 못한 타입 변환 오류 없이 안전하게 타입을 사용할 수 있도록 돕는 개념
- 잘못 사용하면 런타임 오류 발생

### 파고들기

제 경험상 상위 타입을 하위 타입 대체할 때(공변성) 문제되는 경우는 거의 없던 걸로 기억합니다.

이유에 대해서 찾아보니 객체 지향의 기본적인 **다형성**의 개념과 관련되어 있었습니다.

일반적인 객체 지향 프로그래밍에서:

- 상위 타입변수에 하위 타입 객체를 할당하는 것은 항상 안전합니다.
- 하위 타입 변수에 상위 타입 객체를 할당하는 것은 직접적으로 불가능합니다. (명시적 캐스팅 없이는)

```java
// Animal의 자식으로 Dog가 있다는 가정하에
Dog myDog = new Animal(); // 컴파일 오류
```

다시 제네릭 관점에서 봅시다.

- 공변성 (Covariance)

  - `Type<Sub>`을 `Type<Base>`로 대체하는 것
  - 예: `IEnumerable<string>`을 `IEnumerable<object>`로 대체.
  - 이 경우, `IEnumerable<object>`를 사용하는 코드는 object를 "읽을" 것을 기대합니다. `IEnumerable<string>`은 string을 반환하고, string은 object이므로, string을 object로 읽어도 전혀 문제가 없습니다. **여기서는 "하위 타입이 상위 타입을 대체하는" 상황이 제네릭 컨테이너 레벨에서 안전하게 작동합니다.**

- 반공변성 (Contravariance)
  - `Type<Base>`를 `Type<Sub>`로 대체하는 것.
  - 예: `Action<object>`를 `Action<string>`으로 대체.
  - 이 경우, `Action<string>`을 사용하는 코드는 string을 "쓸" 것(매개변수로 전달할 것)을 기대합니다. `Action<object>`는 object를 받아서 처리할 수 있습니다. string은 object이므로, `Action<object>`가 string을 매개변수로 받아 처리해도 문제가 없습니다. 여기서는 "상위 타입이 하위 타입을 대체하는" 상황이 제네릭 컨테이너 레벨에서 안전하게 작동합니다.

### 핵심

핵심은 "읽기"와 "쓰기" (생산자와 소비자)의 관점에서 안전성을 판단하는 것입니다.

- **공변성 (생산자):** 하위 타입이 더 구체적인 데이터를 "생산"하고, 상위 타입은 더 일반적인 데이터를 예상합니다. 구체적인 것을 일반적인 것으로 읽는 것은 항상 안전합니다. (string을 object로 읽는 것)
- **반공변성 (소비자):** 상위 타입이 더 일반적인 데이터를 "소비"할 수 있고, 하위 타입은 더 구체적인 데이터를 전달합니다. 일반적인 소비자가 구체적인 데이터를 받는 것은 항상 안전합니다. (object를 받는 함수에 string을 전달하는 것)

---

## 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

"서브 타입은 언제나 베이스 타입으로 치환될 수 있어야 한다."

또는 "클라이언트가 베이스 타입의 객체를 사용하는 곳에서, 서브 타입의 객체로 교체하더라도 클라이언트의 동작이 변경되어서는 안 된다."

이 원칙은 **다형성의 올바른 사용**을 강조하며, 상속 관계를 설계할 때 매우 중요합니다. 즉, Dog가 Animal을 상속받았을 때, Dog는 Animal이 약속한 모든 동작을 Animal이 기대하는 방식으로 수행해야 한다는 뜻입니다.

### LSP 위반의 예

만약 Bird 클래스가 Animal을 상속받고 fly() 메소드를 가지고 있는데, Penguin 클래스가 Bird를 상속받으면서 fly() 메소드를 오버라이드하여 아무것도 하지 않거나 예외를 던진다면 LSP를 위반한 것입니다. 왜냐하면 Bird를 사용하는 클라이언트 코드는 fly()를 호출하면 새가 날 것으로 기대하기 때문입니다. Penguin 객체로 교체했을 때 이 기대가 깨지면 안 됩니다.

### LSP와 제네릭의 관계

LSP는 주로 **일반적인 객체 상속 계층 구조에서 개별 객체의 행위(behavior)**에 초점을 맞춥니다. 반면, 제네릭의 공변성/반공변성은 타입 매개변수를 가진 컨테이너(`List<T>`, `Action<T>`) 자체의 타입 관계에 초점을 맞춥니다.

---

## 최종 정리

상위 타입은 하위 타입으로 대체할 때는 일반적인 객체 지향 다형성에서 올바른 접근이며 LSP가 강조하는 바.

하지만, 제네릭의 공변성과 반공변성은 "타입 매개변수를 가진 타입들" 간의 할당 가능성으로 확장하면서, "읽기"와 "쓰기"라는 추가적인 맥락을 통해 안전성을 확보하는 방법입니다.
