# 자바의 정석 Chapter 7 - 객체지향 프로그래밍 II

## 1. 상속(Inheritance)

상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것입니다. 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여합니다.

```java
// 부모 클래스 (상위 클래스, 기반 클래스)
class Animal {
    String name;
    int age;

    void eat() {
        System.out.println(name + "이(가) 먹습니다.");
    }

    void sleep() {
        System.out.println(name + "이(가) 잡니다.");
    }
}

// 자식 클래스 (하위 클래스, 파생 클래스)
class Dog extends Animal {
    String breed;  // Dog만의 고유한 멤버

    void bark() {  // Dog만의 고유한 메서드
        System.out.println(name + "이(가) 멍멍 짖습니다.");
    }

    void wagTail() {
        System.out.println(name + "이(가) 꼬리를 흔듭니다.");
    }
}

class Cat extends Animal {
    String furColor;

    void meow() {
        System.out.println(name + "이(가) 야옹하고 웁니다.");
    }
}

public class InheritanceExample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.name = "멍멍이";    // 부모클래스로부터 상속받은 멤버
        dog.age = 3;
        dog.breed = "골든리트리버";

        dog.eat();      // 상속받은 메서드
        dog.sleep();    // 상속받은 메서드
        dog.bark();     // 자신의 메서드
        dog.wagTail();  // 자신의 메서드
    }
}
```

**상속의 특징:**

- 자바에서는 단일상속만을 허용합니다 (extends 뒤에는 하나의 클래스만 올 수 있음)
- 모든 클래스는 Object 클래스의 후손입니다
- 상속관계: "~은 ~이다(is-a)" 관계가 성립해야 합니다

## 2. 클래스간의 관계 - 포함관계

상속관계: "~은 ~이다(is-a)"
포함관계: "~은 ~을 가지고 있다(has-a)"

```java
class Engine {
    int horsepower;
    String type;

    void start() {
        System.out.println("엔진이 시동됩니다.");
    }

    void stop() {
        System.out.println("엔진이 정지됩니다.");
    }
}

class Door {
    String color;
    boolean isOpen;

    void open() {
        isOpen = true;
        System.out.println("문이 열립니다.");
    }

    void close() {
        isOpen = false;
        System.out.println("문이 닫힙니다.");
    }
}

// 포함관계 사용
class Car {
    Engine engine;    // Car has-a Engine
    Door[] doors;     // Car has-a Door
    String model;
    String color;

    Car() {
        engine = new Engine();
        doors = new Door[4];
        for (int i = 0; i < doors.length; i++) {
            doors[i] = new Door();
        }
    }

    void startCar() {
        System.out.println(model + " 시동을 걸어보겠습니다.");
        engine.start();  // 포함된 객체의 메서드 호출
    }
}

public class CompositionExample {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.model = "소나타";
        myCar.startCar();
        myCar.doors[0].open();
    }
}
```

## 3. 메서드 오버라이딩(Method Overriding)

부모 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 합니다.

```java
class Animal {
    void makeSound() {
        System.out.println("동물이 소리를 냅니다.");
    }

    void move() {
        System.out.println("동물이 움직입니다.");
    }
}

class Dog extends Animal {
    // 메서드 오버라이딩
    @Override  // 어노테이션으로 오버라이딩임을 명시
    void makeSound() {
        System.out.println("멍멍!");
    }

    @Override
    void move() {
        System.out.println("개가 네 발로 뛰어갑니다.");
    }
}

class Bird extends Animal {
    @Override
    void makeSound() {
        System.out.println("짹짹!");
    }

    @Override
    void move() {
        System.out.println("새가 하늘을 날아갑니다.");
    }
}

public class OverridingExample {
    public static void main(String[] args) {
        Animal[] animals = {new Dog(), new Bird()};

        for (Animal animal : animals) {
            animal.makeSound();  // 각각 오버라이딩된 메서드 호출
            animal.move();
        }
    }
}
```

**오버라이딩의 조건:**

- 메서드의 선언부(메서드 이름, 매개변수, 반환타입)가 부모클래스의 것과 일치해야 합니다
- 접근 제어자를 부모클래스의 메서드보다 좁은 범위로 변경할 수 없습니다
- 부모클래스의 메서드보다 많은 수의 예외를 선언할 수 없습니다

## 4. 오버로딩 vs 오버라이딩

```java
class Calculator {
    // 오버로딩: 같은 이름의 메서드를 매개변수를 달리해서 정의
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {  // 매개변수 타입이 다름
        return a + b;
    }

    int add(int a, int b, int c) {    // 매개변수 개수가 다름
        return a + b + c;
    }

    void printResult(String message) {
        System.out.println("결과: " + message);
    }
}

class ScientificCalculator extends Calculator {
    // 오버라이딩: 부모의 메서드를 재정의
    @Override
    void printResult(String message) {
        System.out.println("*** 과학 계산기 결과: " + message + " ***");
    }

    // 오버로딩: 새로운 매개변수 조합
    double add(int a, double b) {
        return a + b;
    }
}

public class OverloadingVsOverriding {
    public static void main(String[] args) {
        ScientificCalculator calc = new ScientificCalculator();

        System.out.println(calc.add(1, 2));        // int + int
        System.out.println(calc.add(1.5, 2.5));   // double + double
        System.out.println(calc.add(1, 2, 3));    // 3개 매개변수
        System.out.println(calc.add(1, 2.5));     // int + double

        calc.printResult("10");  // 오버라이딩된 메서드 호출
    }
}
```

## 5. super 키워드

super는 부모 클래스로부터 상속받은 필드나 메서드를 자식 클래스에서 참조하는 데 사용하는 참조 변수입니다.

```java
class Parent {
    int x = 100;

    void method() {
        System.out.println("부모 클래스의 method()");
    }
}

class Child extends Parent {
    int x = 200;  // 부모의 x를 가림 (변수명이 같음)

    void method() {
        System.out.println("자식 클래스의 method()");
    }

    void display() {
        System.out.println("this.x = " + this.x);    // 200 (자식의 x)
        System.out.println("super.x = " + super.x);  // 100 (부모의 x)

        this.method();   // 자식의 method() 호출
        super.method();  // 부모의 method() 호출
    }
}

public class SuperExample {
    public static void main(String[] args) {
        Child child = new Child();
        child.display();
    }
}
```

## 6. super() - 부모 클래스의 생성자

자식 클래스의 생성자에서 부모 클래스의 생성자를 호출할 때 사용합니다.

```java
class Vehicle {
    String brand;
    int year;

    // 부모 클래스의 기본 생성자
    Vehicle() {
        System.out.println("Vehicle() 기본 생성자");
    }

    // 부모 클래스의 매개변수가 있는 생성자
    Vehicle(String brand, int year) {
        this.brand = brand;
        this.year = year;
        System.out.println("Vehicle(String, int) 생성자");
    }
}

class Car extends Vehicle {
    String model;
    int doors;

    // 자식 클래스의 기본 생성자
    Car() {
        super();  // 부모의 기본 생성자 호출 (생략 가능)
        System.out.println("Car() 기본 생성자");
    }

    // 자식 클래스의 매개변수가 있는 생성자
    Car(String brand, int year, String model, int doors) {
        super(brand, year);  // 부모의 생성자 호출 (반드시 첫 번째 줄에)
        this.model = model;
        this.doors = doors;
        System.out.println("Car(String, int, String, int) 생성자");
    }
}

public class SuperConstructorExample {
    public static void main(String[] args) {
        System.out.println("=== Car() 생성자 호출 ===");
        Car car1 = new Car();

        System.out.println("\n=== Car(매개변수) 생성자 호출 ===");
        Car car2 = new Car("현대", 2023, "소나타", 4);

        System.out.println("\n=== 생성된 객체 정보 ===");
        System.out.println("브랜드: " + car2.brand);
        System.out.println("연도: " + car2.year);
        System.out.println("모델: " + car2.model);
        System.out.println("문 개수: " + car2.doors);
    }
}
```

**super() 사용 규칙:**

- 자식 클래스의 생성자에서 첫 번째 줄에 와야 합니다
- super()가 생략되면 컴파일러가 자동으로 super()를 삽입합니다
- 부모 클래스에 기본 생성자가 없고 매개변수가 있는 생성자만 있다면, 반드시 super(매개변수)를 명시해야 합니다

## 7. 패키지(package)

패키지란 클래스의 묶음으로, 클래스나 인터페이스를 포함시킬 수 있습니다. 서로 관련된 클래스들끼리 그룹 단위로 묶어놓음으로써 클래스를 효율적으로 관리할 수 있습니다.

```java
// 패키지 선언 (소스파일의 첫 번째 문장, 주석 제외)
package com.company.project.util;

// 다른 패키지의 클래스 사용을 위한 import
import java.util.ArrayList;
import java.util.List;
import com.company.project.model.Student;  // 다른 패키지의 클래스

public class StringUtils {
    public static boolean isEmpty(String str) {
        return str == null || str.trim().length() == 0;
    }

    public static String reverse(String str) {
        if (isEmpty(str)) return str;
        return new StringBuilder(str).reverse().toString();
    }
}

// 같은 패키지 내의 다른 클래스
class DateUtils {
    // 같은 패키지의 StringUtils를 import 없이 사용 가능
    public static String formatDate(String date) {
        if (StringUtils.isEmpty(date)) {
            return "날짜 없음";
        }
        return date;
    }
}
```

## 8. 접근제어자(Access Modifier)

접근제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 합니다.

- `public`: 접근 제한이 전혀 없음
- `protected`: 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근 가능
- `default`: 같은 패키지 내에서만 접근 가능
- `private`: 같은 클래스 내에서만 접근 가능

## 9. 캡슐화와 접근제어자

캡슐화란 클래스나 메서드에서 하나의 문제 해결을 위한 데이터와 메서드를 하나로 묶는 것을 의미합니다. 데이터를 보호하기 위해 접근제어자를 사용합니다.

```java
// 잘못된 예 - 데이터가 노출됨
class BadBankAccount {
    public int balance;  // 잔액이 public으로 노출됨

    public void deposit(int amount) {
        balance += amount;
    }
}

// 올바른 예 - 캡슐화 적용
class GoodBankAccount {
    private int balance;        // 잔액을 private으로 보호
    private String accountNumber;
    private String ownerName;

    public GoodBankAccount(String accountNumber, String ownerName) {
        this.accountNumber = accountNumber;
        this.ownerName = ownerName;
        this.balance = 0;
    }

    // 입금: 유효성 검사 후 처리
    public boolean deposit(int amount) {
        if (amount <= 0) {
            System.out.println("입금액은 0보다 커야 합니다.");
            return false;
        }
        balance += amount;
        System.out.println(amount + "원이 입금되었습니다. 잔액: " + balance + "원");
        return true;
    }

    // 출금: 잔액 확인 후 처리
    public boolean withdraw(int amount) {
        if (amount <= 0) {
            System.out.println("출금액은 0보다 커야 합니다.");
            return false;
        }
        if (balance < amount) {
            System.out.println("잔액이 부족합니다. 현재 잔액: " + balance + "원");
            return false;
        }
        balance -= amount;
        System.out.println(amount + "원이 출금되었습니다. 잔액: " + balance + "원");
        return true;
    }

    // 잔액 조회: 읽기만 허용
    public int getBalance() {
        return balance;
    }

    // 계좌 정보 조회
    public String getAccountInfo() {
        return "계좌번호: " + accountNumber + ", 예금주: " + ownerName;
    }
}

public class EncapsulationExample {
    public static void main(String[] args) {
        // 잘못된 예시
        BadBankAccount badAccount = new BadBankAccount();
        badAccount.balance = -1000;  // 음수 잔액 설정 가능 (문제!)
        System.out.println("잘못된 계좌 잔액: " + badAccount.balance);

        // 올바른 예시
        GoodBankAccount goodAccount = new GoodBankAccount("123-456-789", "홍길동");

        goodAccount.deposit(10000);   // 정상 입금
        goodAccount.deposit(-500);    // 비정상 입금 시도

        goodAccount.withdraw(3000);   // 정상 출금
        goodAccount.withdraw(15000);  // 잔액 부족으로 출금 실패

        System.out.println("현재 잔액: " + goodAccount.getBalance() + "원");
        System.out.println(goodAccount.getAccountInfo());

        // goodAccount.balance = -1000;  // 컴파일 에러! private 멤버 접근 불가
    }
}
```

이처럼 캡슐화를 통해 데이터의 무결성을 보장하고, 객체의 내부 구현을 숨겨 안전한 프로그래밍이 가능해집니다.

## 10. 다형성(Polymorphism)

다형성이란 여러 가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현했습니다.

```java
// 부모 클래스
class Shape {
    protected String color;

    public Shape(String color) {
        this.color = color;
    }

    public void draw() {
        System.out.println(color + " 도형을 그립니다.");
    }

    public double getArea() {
        return 0;
    }
}

// 자식 클래스들
class Circle extends Shape {
    private double radius;

    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println(color + " 원을 그립니다. 반지름: " + radius);
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width, height;

    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }

    @Override
    public void draw() {
        System.out.println(color + " 사각형을 그립니다. " + width + " x " + height);
    }

    @Override
    public double getArea() {
        return width * height;
    }
}

class Triangle extends Shape {
    private double base, height;

    public Triangle(String color, double base, double height) {
        super(color);
        this.base = base;
        this.height = height;
    }

    @Override
    public void draw() {
        System.out.println(color + " 삼각형을 그립니다. 밑변: " + base + ", 높이: " + height);
    }

    @Override
    public double getArea() {
        return (base * height) / 2;
    }
}

public class PolymorphismExample {
    public static void main(String[] args) {
        // 다형성: 하나의 타입으로 여러 객체 참조
        Shape[] shapes = {
            new Circle("빨간", 5),
            new Rectangle("파란", 4, 6),
            new Triangle("녹색", 3, 8),
            new Circle("노란", 3)
        };

        // 각 객체의 실제 타입에 따라 오버라이딩된 메서드가 호출됨
        System.out.println("=== 모든 도형 그리기 ===");
        for (Shape shape : shapes) {
            shape.draw();  // 런타임에 실제 객체의 메서드 호출
        }

        System.out.println("\n=== 모든 도형의 넓이 ===");
        double totalArea = 0;
        for (Shape shape : shapes) {
            double area = shape.getArea();
            System.out.println("넓이: " + String.format("%.2f", area));
            totalArea += area;
        }
        System.out.println("총 넓이: " + String.format("%.2f", totalArea));

        // 참조변수의 형변환
        System.out.println("\n=== 형변환 예제 ===");
        Shape shape = new Circle("보라", 10);

        // 자동 형변환 (업캐스팅)
        System.out.println("Shape로 참조: ");
        shape.draw();

        // 강제 형변환 (다운캐스팅) - instanceof로 확인 후
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            System.out.println("Circle로 다운캐스팅 성공");
            circle.draw();
        }

        // 잘못된 형변환 방지
        if (shape instanceof Rectangle) {
            System.out.println("Rectangle으로 형변환 가능");
        } else {
            System.out.println("Rectangle으로 형변환 불가능");
        }
    }

    // 다형성을 활용한 메서드
    public static void printShapeInfo(Shape shape) {
        shape.draw();
        System.out.println("넓이: " + shape.getArea());

        // 특정 타입에서만 사용 가능한 기능이 필요한 경우
        if (shape instanceof Circle) {
            System.out.println("이것은 원입니다.");
        } else if (shape instanceof Rectangle) {
            System.out.println("이것은 사각형입니다.");
        }
    }
}
```

**다형성의 장점:**

- 코드의 유연성과 확장성이 증가합니다
- 하나의 배열로 서로 다른 종류의 객체를 다룰 수 있습니다
- 메서드의 매개변수로 부모타입을 사용하면 모든 자식 객체를 처리할 수 있습니다
- 새로운 클래스를 추가해도 기존 코드의 수정이 최소화됩니다

이러한 개념들은 객체지향 프로그래밍의 핵심이며, 실제 프로젝트에서 코드의 재사용성, 유지보수성, 확장성을 크게 향상시키는 중요한 요소입니다.

## 11. 추상클래스(Abstract Class)

추상클래스는 미완성 설계도에 비유할 수 있습니다. 미완성 메서드(추상메서드)를 포함하고 있는 클래스입니다.

```java
// 추상클래스 정의
abstract class Employee {
    protected String name;
    protected int salary;

    public Employee(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }

    // 일반 메서드 (구현부가 있음)
    public void showInfo() {
        System.out.println("이름: " + name + ", 기본급: " + salary);
    }

    // 추상메서드 (구현부가 없음) - 자식클래스에서 반드시 구현해야 함
    public abstract double calculatePay();
    public abstract void work();
}

// 정규직 직원
class FullTimeEmployee extends Employee {
    private double bonus;

    public FullTimeEmployee(String name, int salary, double bonus) {
        super(name, salary);
        this.bonus = bonus;
    }

    @Override
    public double calculatePay() {
        return salary + bonus;  // 기본급 + 보너스
    }

    @Override
    public void work() {
        System.out.println(name + " 정규직이 8시간 근무합니다.");
    }
}

// 파트타임 직원
class PartTimeEmployee extends Employee {
    private int hoursWorked;
    private double hourlyRate;

    public PartTimeEmployee(String name, int baseSalary, int hours, double rate) {
        super(name, baseSalary);
        this.hoursWorked = hours;
        this.hourlyRate = rate;
    }

    @Override
    public double calculatePay() {
        return hoursWorked * hourlyRate;  // 시간 * 시급
    }

    @Override
    public void work() {
        System.out.println(name + " 파트타임이 " + hoursWorked + "시간 근무합니다.");
    }
}

// 계약직 직원
class ContractEmployee extends Employee {
    private double contractAmount;

    public ContractEmployee(String name, double amount) {
        super(name, 0);  // 기본급 없음
        this.contractAmount = amount;
    }

    @Override
    public double calculatePay() {
        return contractAmount;  // 계약금액
    }

    @Override
    public void work() {
        System.out.println(name + " 계약직이 프로젝트를 수행합니다.");
    }
}

public class AbstractClassExample {
    public static void main(String[] args) {
        // Employee emp = new Employee("홍길동", 3000000);  // 에러! 추상클래스는 인스턴스 생성 불가

        Employee[] employees = {
            new FullTimeEmployee("김철수", 3000000, 500000),
            new PartTimeEmployee("이영희", 0, 120, 15000),
            new ContractEmployee("박민수", 8000000)
        };

        System.out.println("=== 직원 정보 및 급여 ===");
        double totalPay = 0;

        for (Employee emp : employees) {
            emp.showInfo();           // 공통 메서드
            emp.work();               // 각자 다르게 구현된 추상메서드
            double pay = emp.calculatePay();  // 각자 다르게 구현된 추상메서드
            System.out.println("급여: " + String.format("%.0f", pay) + "원");
            totalPay += pay;
            System.out.println();
        }

        System.out.println("총 급여 지출: " + String.format("%.0f", totalPay) + "원");
    }
}
```

**추상클래스의 특징:**

- abstract 키워드를 사용하여 선언합니다
- 추상메서드를 포함할 수 있습니다 (일반메서드도 포함 가능)
- 인스턴스를 직접 생성할 수 없습니다
- 자식클래스에서 추상메서드를 반드시 구현해야 합니다
- 생성자, 필드, 일반메서드를 가질 수 있습니다

## 12. 인터페이스(Interface)

인터페이스는 일종의 추상클래스로, 추상메서드와 상수만을 멤버로 가질 수 있습니다. (Java 8부터는 default 메서드와 static 메서드도 가능)

```java
// 인터페이스 정의
interface Drawable {
    // 상수 (public static final이 자동으로 붙음)
    int MAX_SIZE = 100;

    // 추상메서드 (public abstract가 자동으로 붙음)
    void draw();
    void resize(int size);
}

interface Movable {
    void move(int x, int y);
    int getX();
    int getY();
}

// 여러 인터페이스를 구현할 수 있음
class DrawableCircle implements Drawable, Movable {
    private int x, y;
    private int radius;

    public DrawableCircle(int x, int y, int radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("(" + x + ", " + y + ")에 반지름 " + radius + "인 원을 그립니다.");
    }

    @Override
    public void resize(int size) {
        if (size > 0 && size <= MAX_SIZE) {
            this.radius = size;
            System.out.println("원의 크기를 " + size + "로 변경했습니다.");
        }
    }

    @Override
    public void move(int x, int y) {
        this.x = x;
        this.y = y;
        System.out.println("원을 (" + x + ", " + y + ")로 이동했습니다.");
    }

    @Override
    public int getX() { return x; }

    @Override
    public int getY() { return y; }
}

class DrawableRectangle implements Drawable, Movable {
    private int x, y;
    private int width, height;

    public DrawableRectangle(int x, int y, int width, int height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    @Override
    public void draw() {
        System.out.println("(" + x + ", " + y + ")에 " + width + "x" + height + " 사각형을 그립니다.");
    }

    @Override
    public void resize(int size) {
        if (size > 0 && size <= MAX_SIZE) {
            this.width = size;
            this.height = size;
            System.out.println("사각형의 크기를 " + size + "x" + size + "로 변경했습니다.");
        }
    }

    @Override
    public void move(int x, int y) {
        this.x = x;
        this.y = y;
        System.out.println("사각형을 (" + x + ", " + y + ")로 이동했습니다.");
    }

    @Override
    public int getX() { return x; }

    @Override
    public int getY() { return y; }
}

public class InterfaceExample {
    public static void main(String[] args) {
        // 인터페이스 타입의 참조변수로 구현 객체 참조
        Drawable[] drawables = {
            new DrawableCircle(10, 20, 5),
            new DrawableRectangle(30, 40, 8, 6)
        };

        System.out.println("=== 그리기 ===");
        for (Drawable d : drawables) {
            d.draw();
        }

        System.out.println("\n=== 크기 변경 ===");
        for (Drawable d : drawables) {
            d.resize(15);
            d.draw();
        }

        // 인터페이스를 통한 다중상속 효과
        System.out.println("\n=== 이동 ===");
        Movable[] movables = {
            new DrawableCircle(0, 0, 10),
            new DrawableRectangle(0, 0, 5, 5)
        };

        for (Movable m : movables) {
            System.out.println("현재 위치: (" + m.getX() + ", " + m.getY() + ")");
            m.move(100, 200);

            // 형변환을 통해 다른 인터페이스의 메서드도 호출 가능
            if (m instanceof Drawable) {
                ((Drawable) m).draw();
            }
        }

        // 상수 사용
        System.out.println("\n최대 크기: " + Drawable.MAX_SIZE);
    }
}
```

## 13. 인터페이스를 이용한 다중상속

자바는 클래스의 다중상속을 허용하지 않지만, 인터페이스의 다중상속은 허용합니다.

```java
interface Flyable {
    void fly();
    default void takeOff() {  // Java 8부터 default 메서드 가능
        System.out.println("이륙 준비 중...");
    }
}

interface Swimmable {
    void swim();
    default void dive() {
        System.out.println("다이빙 중...");
    }
}

interface Walkable {
    void walk();
}

// 여러 인터페이스를 동시에 구현
class Duck implements Flyable, Swimmable, Walkable {
    private String name;

    public Duck(String name) {
        this.name = name;
    }

    @Override
    public void fly() {
        System.out.println(name + " 오리가 하늘을 날아갑니다.");
    }

    @Override
    public void swim() {
        System.out.println(name + " 오리가 물에서 헤엄칩니다.");
    }

    @Override
    public void walk() {
        System.out.println(name + " 오리가 뒤뚱뒤뚱 걷습니다.");
    }

    // default 메서드 오버라이딩도 가능
    @Override
    public void takeOff() {
        System.out.println(name + " 오리가 물 위에서 이륙합니다.");
    }
}

class Fish implements Swimmable {
    private String name;

    public Fish(String name) {
        this.name = name;
    }

    @Override
    public void swim() {
        System.out.println(name + " 물고기가 빠르게 헤엄칩니다.");
    }
}

class Bird implements Flyable, Walkable {
    private String name;

    public Bird(String name) {
        this.name = name;
    }

    @Override
    public void fly() {
        System.out.println(name + " 새가 자유롭게 날아갑니다.");
    }

    @Override
    public void walk() {
        System.out.println(name + " 새가 깡총깡총 걷습니다.");
    }
}

public class MultipleInheritanceExample {
    public static void main(String[] args) {
        Duck duck = new Duck("도날드");
        Fish fish = new Fish("니모");
        Bird bird = new Bird("트위티");

        System.out.println("=== 오리의 다양한 행동 ===");
        duck.takeOff();  // default 메서드 (오버라이딩된 버전)
        duck.fly();
        duck.swim();
        duck.walk();
        duck.dive();     // default 메서드

        System.out.println("=== 물에서 수영하는 동물들 ===");
        Swimmable[] swimmers = {duck, fish};
        for (Swimmable swimmer : swimmers) {
            swimmer.swim();
            swimmer.dive();
        }

        System.out.println("=== 하늘을 나는 동물들 ===");
        Flyable[] flyers = {duck, bird};
        for (Flyable flyer : flyers) {
            flyer.takeOff();
            flyer.fly();
        }

        System.out.println("=== 걸을 수 있는 동물들 ===");
        Walkable[] walkers = {duck, bird};
        for (Walkable walker : walkers) {
            walker.walk();
        }
    }
}
```

## 14. 인터페이스와 추상클래스의 비교

| 구분       | 추상클래스                       | 인터페이스                                         |
| ---------- | -------------------------------- | -------------------------------------------------- |
| 상속       | 단일상속 (extends)               | 다중구현 (implements)                              |
| 변수       | 모든 종류 가능                   | public static final만 가능                         |
| 메서드     | 추상메서드, 일반메서드 모두 가능 | 추상메서드, default, static 메서드                 |
| 생성자     | 가능                             | 불가능                                             |
| 접근제어자 | 모든 접근제어자 사용 가능        | public만 가능 (생략시 자동으로 public)             |
| 목적       | 공통 기능의 구현과 강제 구현     | 표준화된 규칙(명세) 제공, 교체 가능성(유연성) 제공 |

이러한 객체지향 프로그래밍의 핵심 개념들을 잘 이해하고 활용하면, 유지보수가 쉽고 확장 가능한 프로그램을 작성할 수 있습니다.
