# 자바의 직렬화, 역직렬화

## 직렬화(Serialization) 개념

**직렬화란**

- 메모리에 있는 객체를 바이트 스트림으로 변환하는 과정
- 객체의 상태 정보를 저장 가능한 형태로 변환
- 파일 저장, 네트워크 전송, 데이터베이스 저장 등에 활용

**역직렬화(Deserialization)란**

- 바이트 스트림을 다시 객체로 복원하는 과정
- 저장된 객체의 상태를 메모리에 재구성

**직렬화의 필요성**

- 객체의 영속성(Persistence) 제공
- 분산 시스템에서 객체 전송
- 캐싱 메커니즘 구현
- 딥카피(Deep Copy) 구현

## Serializable 인터페이스

**기본 구현**

```java
import java.io.Serializable;

public class Person implements Serializable {
    private String name;
    private int age;
    private String email;

    // 생성자, getter, setter 등
    public Person(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
}
```

**마커 인터페이스 특성**

- Serializable은 메서드가 없는 마커 인터페이스
- JVM에게 해당 클래스가 직렬화 가능함을 알림
- 구현하지 않으면 NotSerializableException 발생

## 직렬화/역직렬화 구현

**객체 직렬화**

```java
import java.io.*;

public class SerializationExample {
    public static void main(String[] args) {
        Person person = new Person("홍길동", 25, "hong@email.com");

        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream("person.ser"))) {
            oos.writeObject(person);
            System.out.println("직렬화 완료");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

**객체 역직렬화**

```java
public class DeserializationExample {
    public static void main(String[] args) {
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream("person.ser"))) {
            Person person = (Person) ois.readObject();
            System.out.println("역직렬화 완료: " + person);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

## serialVersionUID

**serialVersionUID의 역할**

- 직렬화된 객체의 버전을 나타내는 고유 식별자
- 클래스 구조 변경 시 호환성 확인
- 명시하지 않으면 컴파일러가 자동 생성

```java
public class Person implements Serializable {
    private static final long serialVersionUID = 1L;

    private String name;
    private int age;
    // ...
}
```

**serialVersionUID 불일치 시**

```java
// InvalidClassException 발생
// 클래스의 serialVersionUID가 다를 때
```

**권장사항**

- 명시적으로 serialVersionUID 선언
- 클래스 변경 시 버전 관리 고려
- 호환성이 깨지는 변경 시 값 변경

## transient 키워드

**transient 필드**

- 직렬화에서 제외되는 필드
- 보안이 중요한 데이터나 임시 데이터에 사용

```java
public class User implements Serializable {
    private static final long serialVersionUID = 1L;

    private String username;
    private transient String password; // 직렬화 제외
    private transient int loginCount;  // 직렬화 제외

    // 역직렬화 후 transient 필드는 기본값으로 초기화됨
    // String: null, int: 0, boolean: false 등
}
```

## static 필드와 직렬화

**static 필드의 특성**

```java
public class StaticExample implements Serializable {
    private static final long serialVersionUID = 1L;

    private String instanceField;
    private static String staticField = "정적 필드"; // 직렬화되지 않음

    // static 필드는 클래스에 속하므로 직렬화되지 않음
    // 역직렬화 시 현재 클래스의 static 필드 값 사용
}
```

## 상속과 직렬화

**부모 클래스가 Serializable을 구현한 경우**

```java
// 부모 클래스
public class Animal implements Serializable {
    private static final long serialVersionUID = 1L;
    protected String name;
}

// 자식 클래스 - 자동으로 직렬화 가능
public class Dog extends Animal {
    private String breed;
}
```

**부모 클래스가 Serializable을 구현하지 않은 경우**

```java
// 부모 클래스 (Serializable 구현 안함)
public class Vehicle {
    protected String brand;

    public Vehicle() {} // 기본 생성자 필요
}

// 자식 클래스
public class Car extends Vehicle implements Serializable {
    private static final long serialVersionUID = 1L;
    private String model;

    // 부모 클래스의 필드는 직렬화되지 않음
    // 역직렬화 시 부모의 기본 생성자 호출됨
}
```

## 커스텀 직렬화

**writeObject/readObject 메서드 오버라이드**

```java
public class CustomSerialization implements Serializable {
    private static final long serialVersionUID = 1L;

    private String data;
    private transient String sensitiveData;

    // 커스텀 직렬화
    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject(); // 기본 직렬화 수행

        // 추가 직렬화 로직
        String encrypted = encrypt(sensitiveData);
        oos.writeObject(encrypted);
    }

    // 커스텀 역직렬화
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject(); // 기본 역직렬화 수행

        // 추가 역직렬화 로직
        String encrypted = (String) ois.readObject();
        this.sensitiveData = decrypt(encrypted);
    }

    private String encrypt(String data) {
        // 암호화 로직
        return "encrypted_" + data;
    }

    private String decrypt(String encrypted) {
        // 복호화 로직
        return encrypted.replace("encrypted_", "");
    }
}
```

## Externalizable 인터페이스

**완전한 직렬화 제어**

```java
import java.io.Externalizable;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.IOException;

public class ExternalizableExample implements Externalizable {
    private String name;
    private int age;

    // 기본 생성자 필수
    public ExternalizableExample() {}

    public ExternalizableExample(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeObject(name);
        out.writeInt(age);
        // 직렬화할 필드를 명시적으로 지정
    }

    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        name = (String) in.readObject();
        age = in.readInt();
        // 역직렬화 순서는 직렬화 순서와 동일해야 함
    }
}
```

## 직렬화 성능과 최적화

**성능 고려사항**

```java
public class PerformanceExample implements Serializable {
    private static final long serialVersionUID = 1L;

    private List<String> largeList;
    private transient Map<String, String> cache; // 캐시는 제외

    // 직렬화 성능 향상을 위한 커스텀 구현
    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject();

        // 대용량 데이터를 압축하여 저장
        byte[] compressed = compress(largeList);
        oos.writeObject(compressed);
    }

    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject();

        // 압축된 데이터를 복원
        byte[] compressed = (byte[]) ois.readObject();
        this.largeList = decompress(compressed);

        // 캐시 초기화
        this.cache = new HashMap<>();
    }

    private byte[] compress(List<String> data) {
        // 압축 알고리즘 구현
        return new byte[0];
    }

    private List<String> decompress(byte[] compressed) {
        // 압축 해제 알고리즘 구현
        return new ArrayList<>();
    }
}
```

## 직렬화 보안 이슈

**보안 취약점**

- 역직렬화 시 임의 코드 실행 가능
- 신뢰할 수 없는 데이터 역직렬화 금지

**보안 강화 방법**

```java
public class SecureSerialization implements Serializable {
    private static final long serialVersionUID = 1L;

    private String data;

    // 역직렬화 시 검증
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject();

        // 데이터 유효성 검증
        if (data == null || data.length() > 1000) {
            throw new InvalidObjectException("잘못된 데이터");
        }
    }

    // readResolve로 싱글톤 패턴 보장
    private Object readResolve() throws ObjectStreamException {
        return validateAndReturn();
    }

    private Object validateAndReturn() throws ObjectStreamException {
        // 추가 검증 로직
        return this;
    }
}
```

## 직렬화 대안

**JSON 직렬화**

```java
// Gson, Jackson 등 라이브러리 활용
// 플랫폼 독립적, 가독성 좋음
// 하지만 타입 안정성이 떨어짐
```

**Protocol Buffers**

```java
// 구글에서 개발한 직렬화 라이브러리
// 언어 중립적, 높은 성능
// 스키마 정의 필요
```

**XML 직렬화**

```java
// 가독성이 좋지만 용량이 큼
// JAXB 등의 라이브러리 활용
```
