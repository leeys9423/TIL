# 배열(Array)

## 배열의 기본 개념

**배열이란**

- 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것
- 각 저장공간을 '배열의 요소(element)'라고 하며, 배열이름[인덱스] 형식으로 구분
- 인덱스는 0부터 시작하며 배열길이-1까지 사용

**배열의 선언과 생성**

```java
// 선언
int[] arr;        // 또는 int arr[];
// 생성
arr = new int[5]; // 길이가 5인 int배열 생성
// 선언과 생성을 동시에
int[] arr = new int[5];
```

## 배열의 초기화

**기본값 초기화**

- 배열 생성 시 각 타입의 기본값으로 자동 초기화
- int: 0, boolean: false, 참조형: null

**명시적 초기화**

```java
int[] arr = {1, 2, 3, 4, 5};           // 선언과 동시에
int[] arr = new int[]{1, 2, 3, 4, 5}; // new 연산자 사용
```

## 배열의 활용

**배열의 길이**

- `배열이름.length`로 배열의 길이를 얻을 수 있음
- 한 번 생성된 배열의 길이는 변경할 수 없음

**배열의 복사**

- for문을 이용한 복사
- `System.arraycopy()` 메서드 사용
- `Arrays.copyOf()` 메서드 사용

## String 배열

**String 배열의 특징**

- 참조형 배열로 실제 문자열이 아닌 문자열의 주소를 저장
- 초기값은 null
- `String[] name = {"Kim", "Park", "Lee"};`

**커맨드 라인 인수**

- `main` 메서드의 매개변수 `String[] args`
- 프로그램 실행 시 전달되는 문자열들

**String... vs String[]**

| 구분              | String... args         | String[] args        |
| ----------------- | ---------------------- | -------------------- |
| **매개변수 개수** | 0개 이상 가능          | 정확히 1개 (배열)    |
| **호출 방식**     | 개별 값들 또는 배열    | 배열만 가능          |
| **편의성**        | 더 유연하고 편리       | 명시적으로 배열 필요 |
| **내부 처리**     | 컴파일러가 배열로 변환 | 직접 배열 전달       |

`String... args`는 더 유연한 호출을 허용하는 가변인자이고, `String[] args`는 명시적으로 배열을 요구하는 매개변수 가변인자는 메서드 호출 시 편의성을 제공하지만, 내부적으로는 배열로 처리

## 다차원 배열

**2차원 배열**

```java
int[][] arr = new int[4][3];  // 4행 3열
int[][] arr = {{1,2,3}, {4,5,6}};  // 초기화와 함께
```

**가변 배열**

- 2차원 배열에서 각 행마다 다른 길이를 가질 수 있음

```java
int[][] arr = new int[3][];
arr[0] = new int[4];  // 첫 번째 행은 길이 4
arr[1] = new int[3];  // 두 번째 행은 길이 3
```

## 배열의 활용 예제

**정렬**

- 버블 정렬, 선택 정렬 등의 알고리즘 구현
- `Arrays.sort()` 메서드 활용

**검색**

- 순차 검색, 이진 검색
- 최대값, 최소값 찾기

## Array.sort()의 정렬 알고리즘

**기본형(Primitive) 배열의 경우**: Dual-Pivot Quicksort

- **시간 복잡도**: O(n log n) 평균, O(n²) 최악의 경우
- **특징**: 많은 데이터셋에서 다른 퀵소트들이 이차 성능으로 저하되는 상황에서도 O(n log n) 성능을 제공하며, 전통적인 단일 피벗 퀵소트보다 일반적으로 더 빠름 Arrays (Java Platform SE 8 )
- **메모리**: 제자리 정렬(in-place)로 추가 메모리를 거의 사용하지 않음

**객체(Object) 배열의 경우**: TimSort(Merge Sort와 Insertion Sort를 조합한 하이브리드 정렬 알고리즘)

- **시간 복잡도**: O(n log n) 보장
- **특징**: **안정 정렬(stable sort)**로, 동일한 값을 가진 요소들의 상대적 위치가 정렬 후에도 유지
- **메모리**: 추가 메모리 공간이 필요

**결론**

- 기본형: 성능을 우선시하여 더 빠른 Dual-Pivot Quicksort 사용
- 객체: 안정성을 보장하는 TimSort 사용
