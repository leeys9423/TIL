# 람다와 스트림

## 1. 람다식(Lambda Expression)

### 1.1 람다식이란?

- **함수형 프로그래밍**을 지원하기 위해 Java 8부터 도입
- **메서드를 하나의 식(expression)으로 표현**한 것
- **익명함수(anonymous function)**라고도 불림
- 메서드를 람다식으로 표현하면 클래스를 작성하고 객체를 생성하지 않아도 메서드를 사용할 수 있음

### 1.2 람다식 작성방법

```java
// 기존 메서드
int max(int a, int b) {
    return a > b ? a : b;
}

// 람다식으로 변환
(int a, int b) -> { return a > b ? a : b; }

// 더 간단히
(a, b) -> a > b ? a : b
```

**작성 규칙:**

- 매개변수의 타입을 추론할 수 있는 경우 생략 가능
- 매개변수가 하나인 경우 괄호() 생략 가능 (단, 타입이 있으면 괄호 필수)
- 실행문이 하나인 경우 중괄호{} 생략 가능
- 실행문이 return문 하나인 경우 return과 중괄호 생략 가능

### 1.3 함수형 인터페이스(Functional Interface)

- **람다식은 익명객체이며, 함수형 인터페이스로만 다룰 수 있음**
- 함수형 인터페이스: **오직 하나의 추상 메서드만 정의된 인터페이스**
- `@FunctionalInterface` 어노테이션을 붙여 컴파일러가 체크하도록 함

```java
@FunctionalInterface
interface MyFunction {
    int max(int a, int b);
}

MyFunction f = (a, b) -> a > b ? a : b;
int result = f.max(3, 5); // 5
```

### 1.4 java.util.function 패키지

Java에서 자주 사용되는 형식의 메서드를 함수형 인터페이스로 미리 정의

**주요 함수형 인터페이스:**

- `Supplier<T>`: 매개변수 없음, 반환값 있음 → `T get()`
- `Consumer<T>`: 매개변수 있음, 반환값 없음 → `void accept(T t)`
- `Function<T,R>`: 일반적인 함수, 하나의 매개변수를 받아서 결과를 반환 → `R apply(T t)`
- `Predicate<T>`: 조건식을 표현, boolean을 반환 → `boolean test(T t)`

```java
// 예시
Supplier<Integer> s = () -> (int)(Math.random() * 100) + 1;
Consumer<Integer> c = i -> System.out.print(i + ", ");
Predicate<Integer> p = i -> i % 2 == 0;
Function<Integer, Integer> f = i -> i / 10 * 10;
```

### 1.5 메서드 참조(Method Reference)

- 람다식이 하나의 메서드만 호출하는 경우 더 간단히 표현
- **클래스이름::메서드이름** 또는 **참조변수::메서드이름**

```java
Function<String, Integer> f1 = (String s) -> Integer.parseInt(s);
Function<String, Integer> f2 = Integer::parseInt; // 메서드 참조

BiFunction<String, String, Boolean> f3 = (s1, s2) -> s1.equals(s2);
BiFunction<String, String, Boolean> f4 = String::equals; // 메서드 참조
```

## 2. 스트림(Stream)

### 2.1 스트림이란?

- **데이터 소스를 추상화**하고, **데이터를 다루는데 자주 사용되는 메서드들을 정의**
- 배열, 컬렉션, 파일 등 다양한 데이터 소스를 **같은 방식으로 다룰 수 있게** 함
- **원본 데이터를 변경하지 않음**
- **일회용**이며 **지연된 연산** 수행

```java
String[] strArr = {"aaa", "ddd", "ccc"};
List<String> strList = Arrays.asList(strArr);

// 배열과 리스트를 동일한 방식으로 정렬
Stream<String> strStream1 = Arrays.stream(strArr);
Stream<String> strStream2 = strList.stream();
```

### 2.2 스트림의 연산

스트림이 제공하는 연산은 **중간 연산**과 **최종 연산**으로 분류

**중간 연산:**

- 연산 결과가 스트림인 연산
- 스트림에 연속해서 중간 연산할 수 있음
- `distinct()`, `filter()`, `limit()`, `skip()`, `peek()`, `sorted()`, `map()`, `flatMap()`

**최종 연산:**

- 연산 결과가 스트림이 아닌 연산
- 스트림의 요소를 소모하므로 단 한 번만 가능
- `forEach()`, `count()`, `max()`, `min()`, `findAny()`, `findFirst()`, `allMatch()`, `anyMatch()`, `noneMatch()`, `toArray()`, `collect()`, `reduce()`

### 2.3 스트림 만들기

```java
// 컬렉션
List<Integer> list = Arrays.asList(1,2,3,4,5);
Stream<Integer> intStream = list.stream();

// 배열
Stream<String> strStream = Arrays.stream(new String[]{"a", "b", "c"});

// 특정 범위의 정수
IntStream intStream = IntStream.range(1, 5); // 1,2,3,4
IntStream intStream = IntStream.rangeClosed(1, 5); // 1,2,3,4,5

// 임의의 수
IntStream intStream = new Random().ints(); // 무한 스트림
IntStream intStream = new Random().ints(10); // 크기가 10인 스트림
```

### 2.4 스트림의 중간연산

**필터링:**

```java
Stream<T> filter(Predicate<T> predicate)
Stream<T> distinct()
```

**변환:**

```java
Stream<R> map(Function<T,R> mapper)
DoubleStream mapToDouble(ToDoubleFunction<T> mapper)
IntStream mapToInt(ToIntFunction<T> mapper)
LongStream mapToLong(ToLongFunction<T> mapper)
```

**정렬:**

```java
Stream<T> sorted()
Stream<T> sorted(Comparator<T> comparator)
```

### 2.5 Optional<T>

- **'T타입의 객체'를 포장해주는 래퍼 클래스**
- 모든 타입의 참조변수를 담을 수 있음
- **null을 직접 다루지 않아도 됨**
- NullPointerException이 발생하지 않는 보다 간결하고 안전한 코드 작성 가능

```java
public final class Optional<T> {
    private final T value; // T타입의 참조변수

    // Optional 객체 생성
    Optional<String> optVal = Optional.of("abc");
    Optional<String> optVal = Optional.ofNullable(null);
    Optional<String> optVal = Optional.empty(); // null을 저장

    // 값 가져오기
    String str1 = optVal.get(); // 값이 null이면 예외발생
    String str2 = optVal.orElse(""); // 값이 null일 때 ""를 반환
    String str3 = optVal.orElseGet(String::new); // 람다식 사용 가능
    String str4 = optVal.orElseThrow(NullPointerException::new); // 예외 발생
}
```

### 2.6 스트림의 최종연산

**forEach():**

```java
void forEach(Consumer<? super T> action)
```

**조건 검사:**

```java
boolean allMatch(Predicate<T> p) // 모든 요소가 조건을 만족하는지
boolean anyMatch(Predicate<T> p) // 한 요소라도 조건을 만족하는지
boolean noneMatch(Predicate<T> p) // 모든 요소가 조건을 만족하지 않는지
```

**통계:**

```java
long count()
Optional<T> max(Comparator<? super T> comparator)
Optional<T> min(Comparator<? super T> comparator)
```

**reduce():**

```java
Optional<T> reduce(BinaryOperator<T> accumulator)
T reduce(T identity, BinaryOperator<T> accumulator)
```

### 2.7 collect()

스트림의 요소를 수집하는 최종연산으로 Collector를 매개변수로 하는 스트림의 최종연산

```java
// 리스트로 수집
List<String> names = stuStream.map(Student::getName).collect(Collectors.toList());

// 배열로 변환
Student[] stuNames = studentStream.toArray(Student[]::new);

// 통계
long count = stuStream.count();
long totalScore = stuStream.mapToInt(Student::getTotalScore).sum();
```

**그룹화와 분할:**

```java
// 그룹화 - groupingBy()
Map<Integer, List<Student>> stuByBan = stuStream
    .collect(Collectors.groupingBy(Student::getBan));

// 분할 - partitioningBy()
Map<Boolean, List<Student>> stuByGender = stuStream
    .collect(Collectors.partitioningBy(Student::isMale));
```

## 3. 람다와 스트림의 장점

### 3.1 코드의 간결성

- 불필요한 코드를 줄이고 가독성을 높임
- 함수형 프로그래밍으로 인한 side effect가 없는 프로그래밍 가능

### 3.2 병렬처리

```java
// 순차 스트림
stream.mapToInt(s -> s.length()).sum();

// 병렬 스트림
stream.parallel().mapToInt(s -> s.length()).sum();
```

### 3.3 지연연산

- 최종연산이 수행되기 전까지는 중간연산이 수행되지 않음
- 불필요한 연산을 피할 수 있어 성능상 이점

## 4. 주의사항

### 4.1 스트림 특징

- 스트림은 **데이터 소스를 변경하지 않음**
- 스트림은 **일회용**임 (Iterator와 같이)
- 스트림은 **작업을 내부 반복으로 처리**함

### 4.2 성능 고려사항

- 소량의 데이터에서는 전통적인 반복문이 더 빠를 수 있음
- 병렬 스트림 사용 시 오버헤드 고려
- 박싱/언박싱 비용을 줄이기 위해 기본형 스트림(IntStream, LongStream, DoubleStream) 사용 권장

## 5. 실무 활용 예제

```java
// 학생 리스트에서 성적이 90점 이상인 학생들의 이름을 가져와 정렬
List<String> result = students.stream()
    .filter(student -> student.getScore() >= 90)
    .map(Student::getName)
    .sorted()
    .collect(Collectors.toList());

// 부서별 평균 급여 계산
Map<String, Double> avgSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ));
```

---

### 함수형 인터페이스 정리

- `Supplier<T>` **(공급자)**: 매개변수 없음, 반환값 있음 → `T get()`

  - 아무것도 받지 않고 뭔가를 **제공/공급**한다
  - 랜덤값 생성, 현재 시간 얻기 등

- `Consumer<T>` **(소비자)**: 매개변수 있음, 반환값 없음 → `void accept(T t)`

  - 받은 것을 **소비/사용**하기만 하고 아무것도 돌려주지 않는다
  - 출력하기, 파일에 쓰기 등

- `Function<T,R>` **(함수)**: 매개변수 있음, 반환값 있음 → `R apply(T t)`

  - 수학의 **함수**처럼 입력을 받아서 **변환/가공**해서 결과를 돌려준다
  - 문자열을 숫자로, 객체에서 특정 필드 추출 등

- `Predicate<T>` **(술어/조건문)**: 매개변수 있음, boolean 반환 → `boolean test(T t)`

  - 문법에서 **술어**는 주어에 대해 참/거짓을 판단하는 부분
  - 조건을 **테스트/검사**해서 맞다/틀렸다를 알려준다
  - 필터링 조건, 유효성 검사 등
