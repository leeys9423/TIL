# 쓰레드

## 프로세스와 쓰레드

### 프로세스(Process)

- 실행 중인 프로그램
- 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리 등)을 할당받아 프로세스가 됨
- 각 프로세스는 독립된 메모리 공간을 가짐

### 쓰레드(Thread)

- 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것
- 모든 프로세스는 최소한 하나 이상의 쓰레드가 존재
- 프로세스 내의 쓰레드들은 프로세스의 자원을 공유

### 멀티쓰레딩의 장단점

**장점:**

- CPU 사용률 향상
- 자원을 보다 효율적으로 사용
- 사용자에 대한 응답성 향상
- 작업이 분리되어 코드가 간결

**단점:**

- 동기화(synchronization)에 주의해야 함
- 교착상태(deadlock)가 발생하지 않도록 주의
- 각 쓰레드가 효율적으로 고르게 실행될 수 있게 해야함

## 쓰레드의 구현과 실행

### Thread 클래스 상속

```java
class MyThread extends Thread {
    public void run() {
        // 쓰레드가 수행할 작업
    }
}

// 사용
MyThread t1 = new MyThread();
t1.start(); // run()이 아닌 start()를 호출!
```

### Runnable 인터페이스 구현

```java
class MyThread implements Runnable {
    public void run() {
        // 쓰레드가 수행할 작업
    }
}

// 사용
Thread t1 = new Thread(new MyThread());
t1.start();
```

start()와 run()의 차이

- run(): 단순히 클래스에 속한 메서드를 호출하는 것
- start(): 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 다음 run()을 호출

## 싱글쓰레드와 멀티쓰레드

### 실행 시간

- 싱글쓰레드: 순차적 실행으로 예측 가능한 시간
- 멀티쓰레드: 컨텍스트 스위칭으로 인해 더 많은 시간이 걸릴 수 있음

### 컨텍스트 스위칭 (Context Switching)

- 프로세스 또는 쓰레드 간 작업 전환
- 현재 진행 중인 작업의 상태를 저장하고 다음 작업의 상태를 읽어오는 작업

## 쓰레드의 우선순위

### 우선순위 설정

```java
// 우선순위 범위: 1~10 (높을수록 우선순위 높음)
thread.setPriority(Thread.MAX_PRIORITY);   // 10
thread.setPriority(Thread.NORM_PRIORITY);  // 5 (기본값)
thread.setPriority(Thread.MIN_PRIORITY);   // 1
```

### 주의사항

- 우선순위는 절대적이지 않고 상대적
- OS의 스케줄링 정책과 JVM 구현에 따라 다름
- 희망사항일 뿐, 확실한 실행 순서를 보장하지 않음

## 쓰레드 그룹(Thread Group)

### 개념

- 서로 관련된 쓰레드를 그룹으로 다루기 위한 것
- 모든 쓰레드는 반드시 쓰레드 그룹에 속함
- 그룹을 지정하지 않으면 main 쓰레드 그룹에 속함

### 주요 메서드

```java
ThreadGroup getThreadGroup()      // 쓰레드 자신이 속한 쓰레드 그룹 반환
void uncaughtException(Thread t, Throwable e)  // 예외 처리
```

## 데몬 쓰레드(Daemon Thread)

### 특징

- 일반 쓰레드의 작업을 돕는 보조적인 역할
- 일반 쓰레드가 모두 종료되면 데몬 쓰레드도 강제 종료
- 가비지 컬렉터, 워드의 자동저장, 화면 자동갱신 등

### 설정 방법

```java
thread.setDaemon(true);  // start() 호출 전에 실행해야 함
boolean isDaemon()       // 데몬 쓰레드인지 확인
```

## 쓰레드의 실행제어

### 쓰레드의 상태

1. NEW: 쓰레드 생성 후 아직 start()가 호출되지 않은 상태
2. RUNNABLE: 실행 중 또는 실행 가능한 상태
3. BLOCKED: 동기화블럭에 의해서 일시정지된 상태
4. WAITING: 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은 일시정지 상태
5. TIME_WAITING: 일시정지시간이 지정된 경우
6. TERMINATED: 쓰레드의 작업이 종료된 상태

### 주요 메서드

```java
static void sleep(long millis)     // 일정시간 동안 쓰레드 일시정지
void join()                        // 지정된 시간동안 쓰레드 실행
void interrupt()                   // 쓰레드의 interrupted상태를 false에서 true로 변경
void suspend()                     // 쓰레드 일시정지 (deprecated)
void resume()                      // suspend()에 의해 일시정지된 쓰레드 실행대기상태로 (deprecated)
static void yield()                // 실행 중에 자신에게 주어진 실행시간을 다른 쓰레드에게 양보
```

#### sleep()

```java
try {
    Thread.sleep(1000); // 1초간 현재 쓰레드 일시정지
} catch(InterruptedException e) {}
```

#### interrupt()

```java
// 쓰레드에게 작업을 멈추라고 요청
thread.interrupt();

// interrupted 상태 확인
boolean isInterrupted()     // 쓰레드의 interrupted 상태 반환
static boolean interrupted() // 현재 쓰레드의 interrupted 상태 반환 후 false로 변경
```

#### join()

```java
try {
    thread.join();    // thread가 종료될 때까지 기다림
    thread.join(2000); // 최대 2초간 기다림
} catch(InterruptedException e) {}
```

## 쓰레드의 동기화(Synchronization)

### 필요성

- 멀티쓰레드에서 공유 데이터를 보호하기 위해
- 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하게 함

### synchronized를 이용한 동기화

```java
// 메서드 전체를 동기화
public synchronized void method() {
    // 임계 영역(critical section)
}

// 특정 블럭을 동기화
synchronized(객체의 참조변수) {
    // 임계 영역
}
```

### wait()와 notify()

```java
void wait()          // 객체의 lock을 풀고 쓰레드를 해당 객체의 waiting pool에 넣음
void notify()        // waiting pool에서 대기중인 쓰레드 중 하나를 깨움
void notifyAll()     // waiting pool에서 대기중인 모든 쓰레드를 깨움
```

### Lock과 Condition

```java
private ReentrantLock lock = new ReentrantLock();
private Condition condition = lock.newCondition();

lock.lock();
try {
    // 임계영역
    condition.await();  // wait()와 같음
    condition.signal(); // notify()와 같음
} finally {
    lock.unlock();
}
```

## 생산자-소비자 문제

### 개념

- 생산자(Producer): 데이터를 만드는 쓰레드
- 소비자(Consumer): 데이터를 사용하는 쓰레드
- 버퍼가 가득 찰 때와 비어있을 때의 동기화 처리

### 해결방법

```java
synchronized void put() {
    while(버퍼가 가득 참) {
        try { wait(); } catch(InterruptedException e) {}
    }
    // 데이터 추가
    notifyAll();
}

synchronized void get() {
    while(버퍼가 비어있음) {
        try { wait(); } catch(InterruptedException e) {}
    }
    // 데이터 제거
    notifyAll();
}
```

## Fork & Join 프레임워크

### 개념

- JDK 1.7에 추가된 병렬 처리 프레임워크
- 작업을 작은 단위로 나누어서(Fork) 여러 쓰레드가 처리한 후 결과를 합치는(Join) 방식

### RecursiveTask 사용

```java
class SumTask extends RecursiveTask<Long> {
    long from, to;

    public Long compute() {
        if(to - from <= 5) {
            return sum();
        }

        long half = (from + to) / 2;
        SumTask leftTask = new SumTask(from, half);
        SumTask rightTask = new SumTask(half + 1, to);

        leftTask.fork();  // 비동기 실행
        return rightTask.compute() + leftTask.join();
    }
}
```

### 주요 포인트 요약

1. 쓰레드 생성: Thread 클래스 상속 vs Runnable 인터페이스 구현
2. start() vs run(): start()로 새로운 호출스택 생성
3. 동기화: synchronized, wait()/notify(), Lock/Condition
4. 쓰레드 상태: NEW → RUNNABLE → BLOCKED/WAITING → TERMINATED
5. 데몬 쓰레드: 보조 쓰레드, 메인 쓰레드 종료시 함께 종료
6. interrupt(): 쓰레드에게 작업 중단 요청
7. join(): 다른 쓰레드가 끝날 때까지 대기
