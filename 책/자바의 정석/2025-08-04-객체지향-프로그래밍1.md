# 객체지향 프로그래밍 I

## 1. 객체지향언어의 특징

### 캡슐화 (Encapsulation)

데이터와 메서드를 하나로 묶고 외부로부터 데이터를 보호하는 것입니다. 접근제어자(private, public 등)를 통해 구현됩니다.

```java
class Person {
    private String name;    // private으로 데이터 보호
    private int age;

    // public 메서드를 통해서만 접근 가능
    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;  // 유효성 검사 후 설정
        }
    }
}
```

### 상속 (Inheritance)

기존 클래스를 재사용하여 새로운 클래스를 작성하는 것으로, 코드의 재사용성을 높입니다.

```java
class Animal {
    String name;

    void eat() {
        System.out.println(name + "이(가) 먹습니다.");
    }
}

class Dog extends Animal {  // Animal 클래스를 상속받음
    void bark() {
        System.out.println(name + "이(가) 멍멍 짖습니다.");
    }
}
```

### 다형성 (Polymorphism)

하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 능력입니다.

```java
Animal animal1 = new Dog();    // Dog 객체를 Animal 타입으로 참조
Animal animal2 = new Cat();    // Cat 객체를 Animal 타입으로 참조
```

## 2. 클래스와 객체

**클래스**는 객체를 정의해놓은 것, 객체의 설계도나 틀입니다.
**객체**는 실제로 존재하는 것, 사물 또는 개념입니다.
**인스턴스**는 클래스로부터 만들어진 객체를 말합니다.

```java
// 클래스 정의 (설계도 역할)
class Car {
    String color;    // 속성
    String model;
    int speed;

    void accelerate() {    // 기능
        speed += 10;
        System.out.println("가속! 현재 속도: " + speed + "km/h");
    }

    void brake() {
        speed -= 10;
        if (speed < 0) speed = 0;
        System.out.println("감속! 현재 속도: " + speed + "km/h");
    }
}

// 객체 생성 및 사용
public class CarTest {
    public static void main(String[] args) {
        Car myCar = new Car();    // Car 클래스의 인스턴스 생성
        myCar.color = "빨강";
        myCar.model = "소나타";
        myCar.speed = 0;

        myCar.accelerate();    // 메서드 호출
        myCar.brake();

        Car yourCar = new Car();  // 또 다른 인스턴스
        yourCar.color = "파랑";   // 각 인스턴스는 독립적인 속성을 가짐
    }
}
```

## 3. 변수의 종류

변수는 선언된 위치에 따라 인스턴스 변수, 클래스 변수, 지역 변수로 나뉩니다.

```java
class Calculator {
    int result;              // 인스턴스 변수: 각 인스턴스마다 다른 값
    static int count = 0;    // 클래스 변수: 모든 인스턴스가 공유

    void add(int num) {
        int temp = result;   // 지역 변수: 메서드 내에서만 사용
        result += num;
        count++;             // 클래스 변수는 모든 인스턴스에서 공유
        System.out.println(temp + " + " + num + " = " + result);
    }
}

public class VarTest {
    public static void main(String[] args) {
        Calculator calc1 = new Calculator();
        Calculator calc2 = new Calculator();

        calc1.add(10);  // calc1.result = 10, count = 1
        calc2.add(20);  // calc2.result = 20, count = 2

        System.out.println("calc1 결과: " + calc1.result);  // 10
        System.out.println("calc2 결과: " + calc2.result);  // 20
        System.out.println("총 계산 횟수: " + Calculator.count);  // 2
    }
}
```

- **인스턴스 변수**: 각 인스턴스의 개별적인 저장공간으로, 인스턴스마다 다른 값을 가질 수 있습니다.
- **클래스 변수**: 같은 클래스의 모든 인스턴스들이 공통된 저장공간을 공유하며, static 키워드를 사용합니다.
- **지역 변수**: 메서드 내에 선언되어 메서드 내에서만 사용 가능한 변수입니다.

## 4. 메서드

메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것입니다. 코드의 중복을 줄이고 프로그램을 구조화할 수 있습니다.

```java
class MathUtils {
    // 반환타입이 있는 메서드
    int add(int a, int b) {
        return a + b;
    }

    // 반환타입이 void인 메서드
    void printResult(int result) {
        System.out.println("결과: " + result);
    }

    // 매개변수가 없는 메서드
    void sayHello() {
        System.out.println("안녕하세요!");
    }

    // 여러 개의 매개변수를 가진 메서드
    double calculateArea(double width, double height) {
        return width * height;
    }
}
```

## 5. return문

메서드의 실행을 중단하고 호출한 메서드로 되돌아가는 역할을 합니다. 반환타입이 void가 아닌 경우 반드시 return문이 있어야 합니다.

```java
class NumberChecker {
    // 조건에 따른 조기 return
    String checkNumber(int num) {
        if (num > 0) {
            return "양수";      // 여기서 메서드 종료
        }
        if (num < 0) {
            return "음수";      // 여기서 메서드 종료
        }
        return "영";           // 마지막 return
    }

    // void 메서드에서의 return
    void printOnlyPositive(int num) {
        if (num <= 0) {
            return;  // 메서드 실행 중단하고 돌아감
        }
        System.out.println("양수입니다: " + num);
    }
}
```

## 6. 기본형 매개변수와 참조형 매개변수

매개변수의 타입에 따라 메서드 호출 시 값의 전달 방식이 달라집니다.

```java
class ParamTest {
    // 기본형 매개변수 - 값만 복사됨 (read only)
    void changeValue(int x) {
        x = 1000;  // 복사된 값만 변경, 원본에는 영향 없음
        System.out.println("메서드 내부 x: " + x);
    }

    // 참조형 매개변수 - 주소가 복사됨 (read & write)
    void changeArray(int[] arr) {
        arr[0] = 1000;  // 원본 배열의 값이 변경됨
        System.out.println("메서드 내부 arr[0]: " + arr[0]);
    }
}

public class ParamExample {
    public static void main(String[] args) {
        ParamTest pt = new ParamTest();

        int value = 10;
        System.out.println("호출 전 value: " + value);
        pt.changeValue(value);
        System.out.println("호출 후 value: " + value);  // 10 (변경되지 않음)

        int[] array = {10, 20, 30};
        System.out.println("호출 전 array[0]: " + array[0]);
        pt.changeArray(array);
        System.out.println("호출 후 array[0]: " + array[0]);  // 1000 (변경됨)
    }
}
```

## 7. 재귀호출 (Recursive Call)

메서드가 자기 자신을 다시 호출하는 것입니다. 반복문으로 바꿀 수 있으며, 보통 반복문보다 성능이 떨어집니다.

```java
class RecursiveExample {
    // 팩토리얼 계산 (재귀 방식)
    long factorial(int n) {
        if (n <= 1) {
            return 1;  // 재귀 호출의 탈출 조건
        }
        return n * factorial(n - 1);  // 자기 자신을 호출
    }

    // 같은 기능을 반복문으로 구현
    long factorialLoop(int n) {
        long result = 1;
        for (int i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }

    // 피보나치 수열 (재귀 방식)
    int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```

## 8. 클래스 메서드(static)와 인스턴스 메서드

메서드 앞에 static이 있으면 클래스 메서드, 없으면 인스턴스 메서드입니다.

```java
class Calculator {
    int instanceVar = 10;        // 인스턴스 변수
    static int classVar = 20;    // 클래스 변수

    // 인스턴스 메서드: 인스턴스 생성 후 호출 가능
    void instanceMethod() {
        System.out.println("인스턴스 메서드");
        System.out.println("instanceVar: " + instanceVar);  // OK
        System.out.println("classVar: " + classVar);        // OK
        staticMethod();   // OK: static 메서드 호출 가능
    }

    // 클래스 메서드: 객체 생성 없이 호출 가능
    static void staticMethod() {
        System.out.println("클래스 메서드");
        System.out.println("classVar: " + classVar);        // OK
        // System.out.println("instanceVar: " + instanceVar); // 에러!
        // instanceMethod();  // 에러! 인스턴스 메서드 호출 불가
    }
}

public class MethodTest {
    public static void main(String[] args) {
        // 클래스 메서드는 객체 생성 없이 호출
        Calculator.staticMethod();

        // 인스턴스 메서드는 객체 생성 후 호출
        Calculator calc = new Calculator();
        calc.instanceMethod();
    }
}
```

## 9. 클래스 멤버와 인스턴스 멤버 간의 참조와 호출

**참조와 호출 규칙:**

- **인스턴스 멤버**: 언제나 참조 또는 호출이 가능합니다.
- **static 멤버**: 인스턴스 멤버들을 참조 또는 호출할 수 없습니다.

```java
class TestClass {
    int iv = 10;           // 인스턴스 변수
    static int cv = 20;    // 클래스 변수

    void instanceMethod() {
        System.out.println(iv);    // OK
        System.out.println(cv);    // OK
        staticMethod();            // OK
    }

    static void staticMethod() {
        System.out.println(cv);    // OK
        // System.out.println(iv); // 에러! 인스턴스 변수 사용 불가
        // instanceMethod();       // 에러! 인스턴스 메서드 호출 불가

        // 인스턴스를 생성해서 사용해야 함
        TestClass t = new TestClass();
        System.out.println(t.iv);  // OK
        t.instanceMethod();        // OK
    }
}
```

이러한 개념들은 객체지향 프로그래밍의 기초가 되는 중요한 내용들로, 이후 상속, 다형성 등 더 복잡한 개념을 이해하는 데 필수적입니다.
