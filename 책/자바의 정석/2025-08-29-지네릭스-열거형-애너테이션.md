# 지네릭스, 열거형, 애너테이션

## 1. 지네릭스(Generics)

### 1.1 지네릭스란?

다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크(compile-time type check)를 해주는 기능

**장점:**

- **타입 안정성 제공**: 의도하지 않은 타입의 객체 저장을 방지
- **형변환 번거로움 감소**: 타입체크와 형변환 생략으로 코드 간결화
- **컴파일 타임 에러 검출**: 런타임 에러를 컴파일 타임에 미리 발견

### 1.2 지네릭 클래스 선언

```java
// 지네릭 클래스 정의
class Box<T> {
    T item;
    void setItem(T item) { this.item = item; }
    T getItem() { return item; }
}

// 사용
Box<String> stringBox = new Box<String>();
Box<String> stringBox = new Box<>(); // JDK 1.7부터 타입 추정 가능
```

**용어 정리:**

- `Box<T>`: 지네릭 클래스, 'T의 Box' 또는 'T Box'
- `T`: 타입변수 또는 타입매개변수
- `Box`: 원시타입(raw type)
- `Box<String>`: 지네릭 타입 호출, `String`은 매개변수화된 타입

### 1.3 지네릭스의 제한사항

```java
class Box<T> {
    static T item;                    // ERROR: static 멤버에 타입변수 사용 불가
    static int compare(T t1, T t2) {} // ERROR: static 메서드에 타입변수 사용 불가

    T[] itemArr;                      // OK: 배열 참조변수는 가능
    T[] tmpArr = new T[10];          // ERROR: 지네릭 배열 생성 불가
}
```

### 1.4 제한된 지네릭 클래스

```java
// 특정 타입의 자손들만 허용
class FruitBox<T extends Fruit> {
    ArrayList<T> list = new ArrayList<T>();
}

// 인터페이스 구현 제약 (implements가 아닌 extends 사용)
class FruitBox<T extends Eatable> { ... }

// 클래스와 인터페이스 동시 제약
class FruitBox<T extends Fruit & Eatable> { ... }
```

### 1.5 와일드카드

static 메서드에는 타입 매개변수 T를 매개변수에 사용할 수 없다는 문제를 해결하기 위해 도입

**와일드카드 종류:**

- `<? extends T>`: 상한 제한 (T와 그 자손들만 가능)
- `<? super T>`: 하한 제한 (T와 그 조상들만 가능)
- `<?>`: 제한없음 (`<? extends Object>`와 동일)

```java
// 와일드카드 사용 예
static Juice makeJuice(FruitBox<? extends Fruit> box) {
    String tmp = "";
    for(Fruit f: box.getList()) tmp += f + " ";
    return new Juice(tmp);
}
```

### 1.6 지네릭 메서드

```java
// 메서드 선언부에 지네릭 타입 선언
static <T extends Fruit> Juice makeJuice(FruitBox<T> box) {
    String tmp = "";
    for(Fruit f: box.getList()) tmp += f + " ";
    return new Juice(tmp);
}

// 호출 시 타입 생략 가능
Juicer.makeJuice(appleBox); // 컴파일러가 타입 추정
```

### 1.7 지네릭 타입의 형변환

- **지네릭타입 ↔ 원시타입**: 가능 (경고 발생)
- **지네릭타입 ↔ 지네릭타입**: 불가능
- **와일드카드 지네릭타입 ↔ 지네릭타입**: 가능 (경고 발생)

### 1.8 지네릭 타입의 제거 (Type Erasure)

컴파일러는 지네릭 타입을 이용해서 소스 파일을 체크하고, 필요한 곳에 형변환을 넣어준 뒤 지네릭 타입을 제거한다

**제거 과정:**

1. 지네릭 타입의 경계(bound) 제거
2. 타입 불일치 시 형변환 추가

---

## 2. 열거형(Enums)

### 2.1 열거형이란?

서로 관련된 상수를 편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 사용하면 유용

**Java 열거형의 특징:**

- C언어보다 향상된 기능: 값뿐만 아니라 **타입까지 관리**
- 타입 안전성 보장
- 리컴파일 불필요

### 2.2 열거형 정의와 사용

```java
// 열거형 정의
enum Direction { EAST, WEST, SOUTH, NORTH }

// 사용
Direction dir = Direction.EAST;

// 비교 연산
if (dir == Direction.EAST) { ... }           // == 사용 가능
if (dir.compareTo(Direction.WEST) > 0) { ... } // compareTo 사용

// switch문에서 사용
switch(dir) {
    case EAST: break;  // 열거형 이름 생략
    case WEST: break;
}
```

### 2.3 열거형에 멤버 추가

```java
public enum Transportation {
    BUS(100), TRAIN(150), SHIP(200);

    private final int BASIC_FARE;

    private Transportation(int basicFare) {
        BASIC_FARE = basicFare;
    }

    int fare() { return BASIC_FARE; }
}
```

### 2.4 열거형에 추상 메서드 추가

```java
public enum Transportation {
    BUS(100) {
        int fare(int distance) { return distance * BASIC_FARE; }
    },
    TRAIN(150) {
        int fare(int distance) { return distance * BASIC_FARE; }
    };

    abstract int fare(int distance); // 추상 메서드
    protected final int BASIC_FARE;

    private Transportation(int basicFare) {
        BASIC_FARE = basicFare;
    }
}
```

---

## 3. 애너테이션(Annotation)

### 3.1 애너테이션이란?

소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함 시킨 것

**특징:**

- 주석처럼 프로그래밍 언어에 영향을 미치지 않음
- 다른 프로그램에게 유용한 정보 제공
- `@` 기호로 시작

### 3.2 표준 애너테이션

| 애너테이션             | 설명                                           |
| ---------------------- | ---------------------------------------------- |
| `@Override`            | 컴파일러에게 오버라이딩하는 메서드임을 알림    |
| `@Deprecated`          | 앞으로 사용하지 않을 것을 권장하는 대상에 부착 |
| `@SuppressWarnings`    | 컴파일러의 특정 경고메시지가 나타나지 않게 함  |
| `@SafeVarargs`         | 지네릭스 타입의 가변인자에 사용 (JDK1.7)       |
| `@FunctionalInterface` | 함수형 인터페이스임을 알림 (JDK1.8)            |

```java
class Parent {
    void parentMethod() {}
}

class Child extends Parent {
    @Override
    void parentMethod() {} // 컴파일러가 오버라이딩 검증

    @SuppressWarnings("unused")
    public void method() {
        int unused = 0; // unused 경고 억제
    }
}
```

### 3.3 메타 애너테이션

애너테이션을 위한 애너테이션으로 애너테이션의 적용 대상(target)이나 유지기간(retention)등을 지정하는데 사용된다

#### @Target - 적용 대상 지정

| 대상 타입        | 의미                       |
| ---------------- | -------------------------- |
| `TYPE`           | 클래스, 인터페이스, 열거형 |
| `FIELD`          | 필드(멤버변수, enum 상수)  |
| `METHOD`         | 메서드                     |
| `PARAMETER`      | 매개변수                   |
| `CONSTRUCTOR`    | 생성자                     |
| `LOCAL_VARIABLE` | 지역변수                   |

#### @Retention - 유지 정책

| 유지 정책 | 의미                                              |
| --------- | ------------------------------------------------- |
| `SOURCE`  | 소스 파일에만 존재, 클래스 파일에는 존재하지 않음 |
| `CLASS`   | 클래스 파일에 존재, 실행시에 사용 불가 (기본값)   |
| `RUNTIME` | 클래스 파일에 존재, 실행시에 사용 가능            |

#### 기타 메타 애너테이션

- `@Documented`: javadoc으로 작성한 문서에 포함
- `@Inherited`: 자손 클래스에 상속되도록 함
- `@Repeatable`: 여러 번 붙일 수 있도록 함 (JDK1.8)

### 3.4 애너테이션 타입 정의

```java
// 애너테이션 정의
@interface TestInfo {
    int count() default 1;        // 기본값 지정
    String testBy();              // 필수 요소
    String[] testTools();         // 배열 타입 가능
    TestType testType();          // enum 타입 가능
    DateTime testDate();          // 다른 애너테이션 포함 가능
}

// 사용
@TestInfo(
    count=3,
    testBy="Kim",
    testTools={"JUnit", "AutoTester"},
    testType=TestType.FIRST,
    testDate=@DateTime(yymmdd="160101", hhmmss="235959")
)
public class TestClass { ... }
```

**애너테이션 요소 규칙:**

- 요소의 타입: 기본형, String, enum, 애너테이션, Class만 허용
- 매개변수 선언 불가
- 예외 선언 불가
- 타입 매개변수로 정의 불가

---

## 정리

1. **지네릭스**: 컴파일 타임 타입 체크로 타입 안전성 제공, 런타임 시 타입 정보 제거
2. **열거형**: 타입 안전한 상수 관리, 추상 메서드를 통한 상수별 다른 동작 구현 가능
3. **애너테이션**: 소스코드에 메타데이터 제공, 컴파일러와 다른 도구들이 활용
