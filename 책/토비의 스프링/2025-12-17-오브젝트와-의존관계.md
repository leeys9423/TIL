# 오브젝트와 의존관계

## 1.1 초난감 DAO

**UserDao 초기 버전**: 사용자 정보를 DB에 저장하고 조회하는 단순한 DAO 클래스로 시작. JDBC를 이용해 DB 연결, SQL 실행, 리소스 정리까지 모든 로직이 add()와 get() 메서드 안에 다 들어있는 문제 많은 코드

**문제점**: 코드 중복, 관심사가 분리되지 않음, 변화에 취약한 구조

## 1.2 DAO의 분리

**관심사의 분리**: 중복된 DB 연결 코드를 getConnection() 메서드로 추출하여 중복을 제거

**상속을 통한 확장**: getConnection()을 추상 메서드로 만들고, UserDao를 추상 클래스로 변경. 서브클래스에서 DB 연결 방식을 자유롭게 구현할 수 있게 되는 템플릿 메서드 패턴과 팩토리 메서드 패턴을 적용

**한계**: 상속은 다중상속이 불가능하고, 상하위 클래스가 긴밀하게 결합되어 변경에 어려움이 존재

## 1.3 DAO의 확장

**클래스의 분리**: DB 연결 기능을 SimpleConnectionMaker라는 별도 클래스로 분리. 하지만 특정 클래스에 종속되는 문제가 발생

**인터페이스 도입**: ConnectionMaker 인터페이스를 만들어 구현 클래스와 사용 클래스를 분리. 이를 통해 느슨한 결합을 만들어냅니다.

**관계설정 책임의 분리**: UserDao가 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 책임을 클라이언트(UserDaoTest)로 넘김. 이것이 의존관계 주입(DI)의 시작

## 1.4 제어의 역전(IoC)

**팩토리**: 객체의 생성과 관계설정을 담당하는 DaoFactory 클래스를 만듦. 애플리케이션 컴포넌트 역할을 하는 오브젝트와 구조를 결정하는 오브젝트를 분리

**제어권의 이전**: 프로그램의 제어 흐름 구조가 뒤바뀌는 것이 IoC입니다. 일반적으로는 main()에서 시작해서 사용할 오브젝트를 결정하고 생성하지만, IoC에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하거나 생성하지 않습니다.

## 1.5 스프링의 IoC

**ApplicationContext**: 스프링의 IoC 컨테이너이자 빈 팩토리입니다. DaoFactory를 설정정보로 사용하는 애플리케이션 컨텍스트를 만듭니다.

**@Configuration과 @Bean**: DaoFactory에 @Configuration을 붙이고, 오브젝트를 생성하는 메서드에 @Bean을 붙여 스프링 빈으로 등록합니다.

**장점**: 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없고, 종합적인 IoC 서비스를 제공받으며, 빈을 검색하는 다양한 방법을 제공받습니다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

**싱글톤 패턴의 한계**: private 생성자로 인한 상속 불가, 테스트 어려움, 전역 상태로 인한 문제

**싱글톤 레지스트리**: 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리합니다. 평범한 자바 클래스도 싱글톤으로 활용할 수 있게 해줍니다.

**주의사항**: 싱글톤은 멀티스레드 환경에서 여러 스레드가 동시에 접근할 수 있으므로 상태정보를 내부에 갖지 않는 무상태(stateless) 방식으로 만들어야 합니다.

## 1.7 의존관계 주입(DI)

**의존관계**: A가 B에 의존한다는 것은 B가 변하면 A에 영향을 미친다는 의미입니다.

**의존관계 주입의 조건**: 인터페이스를 통해서만 의존관계를 알고, 런타임 시점에 제3자(IoC 컨테이너)가 실제 의존 오브젝트를 주입해줍니다.

**의존관계 검색**: 스스로 컨테이너에게 빈을 요청하는 방식도 있지만, 의존관계 주입이 더 깔끔합니다.

**DI의 장점**: 코드 변경 없이 구현 클래스 교체 가능, 테스트하기 용이

## 1.8 XML을 이용한 설정

**XML 설정**: 자바 코드 대신 XML로 빈 설정 정보를 작성할 수 있습니다. <beans>, <bean> 태그를 사용합니다.

**프로퍼티 설정**: <property> 태그로 의존 오브젝트를 주입합니다. name은 setter 메서드 이름에서 set을 빼고 첫 글자를 소문자로 바꾼 것입니다.
