# 세마포어, 뮤텍스

어제 자바의 메모리 가시성 문제를 다루면서 경쟁 상태(Race Condition)의 해결 방법에 대해서 세마포어(Semaphore)와 뮤텍스(Mutex)가 있다고 언급했습니다.

각각은 어떠한 동작으로 경쟁 상태를 해결하는 지에 대해서 정리해보겠습니다.

## 경쟁 상태(Race Condition)

어제 글에서도 정리해놓았었지만, 다시 한번 경쟁 상태에 대해 설명드리자면 두 개 이상의 스레드 또는 프로세스가 공유 자원에 동시에 접근하고 수정을 시도할 때 발생할 수 있는 문제를 뜻합니다.

이 문제를 해결하기 위해서는 공유 자원에 쓰기 작업을 할 때에 동시에 접근 하는 것을 막아야 합니다.

## 상호 배제(Mutual Exclusion), 임계 영역(Critical Section)

즉, 한 스레드나 프로세스가 공용 데이터를 사용하고 있으면 다른 프로세스에서 그 자원을 사용하지 못하도록 막으면 근본적으로 해당 문제를 피할 수 있습니다. 이것은 **상호 배제**(Mutual Exclusion)이라고 부르고, 여러 프로세스들이 공유하고 있는 자원을 한 시점에 하나의 프로세스만 접근할 수 있게 하는 영역을 **임계 영역**(Critical Section)이라고 부릅니다.

## 세마포어(Semaphore)

**세마포어**란? 1965년 에츠허 다익스트라(Edsger Dijkstra)가 제안한 **동기화 메커니즘**으로, 여러 프로세스나 스레드가 제한된 수의 자원에 안전하게 접근할 수 있도록 제어하는 도구입니다.

세마포어의 핵심은 **내부 카운터**에 있습니다. 이 카운터는 현재 사용 가능한 자원의 개수를 나타내며, 초기값은 동시에 접근할 수 있는 자원의 최대 개수로 설정됩니다.

### 세마포어의 연산

세마포어는 두 가지 원자적 연산으로 동작합니다.

- wait() 연산 (P 연산): 자원을 요청할 때 사용
  - 카운터가 0보다 크면 카운터를 1 감소시키고 진행
  - 카운터가 0이면 자원이 사용 가능해질 때 까지 대기
- signal() 연산 (V 연산): 자원을 반환할 때 사용
  - 카운터를 1 증가시킴
  - 대기 중인 프로세스가 있다면 하나를 깨움

### 자바 코드 예제 (주차장 관리 시스템)

```java
// 주차장 세마포어 (최대 3대 주차 가능)
Semaphore parkingLot = new Semaphore(3);

// 차량이 주차장에 들어갈 때
public void enterParkingLot() {
    parkingLot.acquire(); // wait() 연산
    System.out.println("차량이 주차했습니다.");
    // 주차 중...
}

// 차량이 주차장에서 나갈 때
public void exitParkingLot() {
    System.out.println("차량이 출차했습니다.");
    parkingLot.release(); // signal() 연산
}
```

이 예시에서 세마포어의 카운터의 변화 관점에서 해석해보면

- 초기값: 3 (3대 주차 가능)
- 첫 번째 차량 진입: 2 (2대 더 주차 가능)
- 두 번째 차량 진입: 1 (1대 더 주차 가능)
- 세 번째 차량 진입: 0 (더 이상 주차 불가)
- 네 번째 차량 시도: 대기 상태
- 한 대 출차: 1 (대기 중인 차량 진입 가능)

이렇게 세마포어는 제한된 자원에 대한 접근을 효율적으로 관리할 수 있게 해줍니다.

### 세마포어는 실제 어디에 사용될까?

1. 커넥션 풀(Connection Pool) 관리
2. 스레드 풀에서 동시 작업 제한
3. 메모리나 CPU 집약적 작업 제어 (메모리를 많이 사용하는 작업을 동시에 N개 까지만 허용)

## 뮤텍스(Mutex)

뮤텍스(Mutex)란? "Mutual Exclusion"의 줄임말로, 말 그대로 상호 배제를 구현하는 동기화 메커니즘입니다.

세마포어와 달리 뮤텍스는 **오직 하나의 스레드**만이 임계 영역에 접근할 수 있도록 보장합니다.

뮤텍스는 본질적으로 카운터가 1인 이진 세마포어와 유사하지만, 중요한 차이점이 있습니다. 바로 **소유권**(Ownership) 개념입니다. 뮤텍스의 **소유권을 가진** 스레드만이 그 **소유권을 반납**할 수 있습니다.

### 뮤텍스의 연산

- **lock() 연산:** 임계 영역에 진입하기 전 잠금을 획득
  - 뮤텍스가 사용 가능하면 잠금을 획득하고 진행
  - 이미 다른 스레드가 잠금을 보유하고 있다면 대기
- **unlock() 연산:** 임계 영역에서 나온 후 잠금을 해제
  - 잠금을 해제하고 대기 중인 다른 스레드에게 기회를 제공
  - **잠금을 획득한 스레드만이 해제할 수 있음**

### 자바 코드 예시 (은행 계좌 관리 시스템)

```java
// 계좌 잔액 보호를 위한 뮤텍스
private final Object accountMutex = new Object();
private int balance = 1000;

// 계좌에서 돈을 인출하는 메서드
public boolean withdraw(int amount) {
    synchronized(accountMutex) { // lock() 연산
        if (balance >= amount) {
            System.out.println("인출 전 잔액: " + balance);
            balance -= amount;
            System.out.println("인출 후 잔액: " + balance);
            return true;
        }
        return false;
    } // unlock() 연산 (자동)
}
```

이 예시에서 뮤텍스의 동작은

- 스레드 A가 withdraw() 호출 → 뮤텍스 잠금 획득
- 스레드 B가 withdraw() 호출 → 스레드 A의 작업 완료까지 대기
- 스레드 A의 작업 완료 → 뮤텍스 해제
- 스레드 B가 뮤텍스 잠금 획득 후 작업 진행

**하나의 공유 자원을 보호**해야 할 때 사용하며, 데이터의 일관성을 보장하는 가장 기본적이고 강력한 도구입니다.

### 자바에서 뮤텍스 구현

자바에서는 `synchronized` 키워드와 `ReentrantLock`을 사용하여 구현할 수 있습니다.(해당 부분은 자바 섹션에서 추후에 다루도록 하겠습니다.)

### 뮤텍스는 실제 어디에 사용될까?

1. 공유 변수 수정
2. 파일 쓰기

> **참고: DB레벨에서의 비관적 락**
>
> 데이터베이스에서 **비관적 락**도 뮤텍스와 비슷하게 동작합니다.
>
> DB 락:
>
> - 데이터베이스 레벨 동기화 (다른 프로세스/서버 간에도 동작)
> - 트랜잭션 기반
> - 네트워크를 통한 분산 환경
>
> ```sql
> SELECT * FROM account WHERE id = 1 FOR UPDATE;  -- 행 락 획득
> UPDATE account SET balance = balance - 100 WHERE id = 1;
> COMMIT;  -- 락 해제
> ```
>
> 비관적 락은 뮤텍스라고 부르기보다는 **뮤텍스와 유사한 동기화 메커니즘** 정도로 이해하는 것이 좋습니다.

## 동기화 메커니즘 사용 시 주의할 점: 교착 상태 (Deadlock)

세마포어와 뮤텍스는 경쟁 상태를 효과적으로 해결하지만, 잘못 사용될 경우 '**교착 상태**(Deadlock)'라는 또 다른 심각한 문제에 직면할 수 있습니다. 교착 상태는 두 개 이상의 스레드/프로세스가 서로 다른 자원의 잠금을 요청하고, 각자 상대방이 가진 자원이 해제되기를 무한정 기다리면서 **시스템이 멈추는 현상**을 말합니다.

### 교착 상태의 일반적인 발생 조건 (에츠허 다익스트라):

- **상호 배제** (Mutual Exclusion): 자원은 한 번에 하나의 프로세스만 사용할 수 있습니다.
- **점유와 대기** (Hold and Wait): 자원을 하나 이상 보유한 상태에서 다른 자원을 기다립니다.
- **비선점** (No Preemption): 자원을 강제로 뺏을 수 없습니다. 자원을 보유한 프로세스만이 자원을 해제할 수 있습니다.
- **순환 대기** (Circular Wait): 프로세스들이 자원을 기다리는 형태가 원형을 이룹니다.

이러한 교착 상태는 시스템의 응답성을 저해하고, 심한 경우 전체 시스템의 마비를 초래할 수 있으므로, 세마포어나 뮤텍스와 같은 동기화 도구를 사용할 때는 교착 상태 발생 가능성을 항상 염두에 두고 신중하게 설계해야 합니다.

교착 상태의 탐지 및 회피 전략에 대해서는 추후 별도의 글에서 더 자세히 다루도록 하겠습니다.
