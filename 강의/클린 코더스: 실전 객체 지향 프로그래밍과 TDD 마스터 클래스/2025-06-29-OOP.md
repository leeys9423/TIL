# 객체지향 프로그래밍(OOP)

## OOP의 정의

**객체지향 프로그래밍(Object-Oriented Programming)**은 프로그램을 **상호작용하는 객체들의 집합**으로 바라보는 프로그래밍 패러다임

## 핵심 개념

- **객체(Object)**: 데이터(속성)와 그 데이터를 조작하는 메서드(행동)를 하나로 묶는 단위
- **클래스(Class)**: 객체를 생성하기 위한 템플릿 또는 설계도
- **메시지 전달**: 객체들 간의 상호작용 방식

## 🔄 절차적 접근 vs 객체지향적 접근

### 절차적 접근: Data Structure -> Function

```java
// 1단계: 먼저 데이터 구조를 정의
struct Employee {
    String name;
    double salary;
    int id;
}

// 2단계: 그 다음에 기능을 만듦
void calculatePay(Employee emp) { /* ... */ }
void promoteEmployee(Employee emp) { /* ... */ }
void printEmployeeInfo(Employee emp) { /* ... */ }
```

**문제점:**

- 데이터와 기능이 분리되어 있음
- 데이터 구조가 변경되면 모든 관련 함수를 수정해야 함
- **데이터 중심 사고:** "어떤 데이터가 필요한가?"

### OOP 접근: Behavior First -> Data

```java
// 1단계: 먼저 행동(기능)을 정의
interface Payable {
    double calculatePay();
}

interface Promotable {
    void promote();
}

// 2단계: 행동을 구현하면서 필요한 데이터를 결정
class Employee implements Payable, Promotable {
    // 행동을 구현하기 위해 필요한 데이터만 정의
    private String name;
    private double salary;  // calculatePay()를 위해 필요
    private int level;      // promote()를 위해 필요

    @Override
    public double calculatePay() {
        return salary * (1 + level * 0.1);
    }

    @Override
    public void promote() {
        this.level++;
    }
}
```

## 🤔 왜 OOP에서는 기능을 먼저 정의할까?

### 1. 행동 중심 사고(Behavior-Driven Thinking)

**절차적 방식:**

- "이 시스템에는 어떤 데이터가 있을까?" -> 데이터부터 설계
- 결과: 사용되지 않는 데이터나 불필요한 복잡성 증가

**OOP 방식:**

- "이 객체는 무엇을 해야 할까?" -> 책임과 역할부터 정의
- 결과: 정말 필요한 데이터만 포함하게 됨

### 2. 인터페이스 설계의 중요성

- 먼저 "무엇을 할 수 있는가?"를 정의
- 그 다음에 구현체에서 필요한 데이터를 결정

### 3. 캡슐화와 정보 은닉

행동을 먼저 정의하면 **외부에 노출할 인터페이스**와 **내부 구현**을 명확히 분리할 수 있음

### 4. 유연성과 확장성

- 행동을 먼저 정의하면 다양한 구현이 가능
- 구현체마다 필요한 데이터가 다름

## 🎯 실제 설계 과정

1. 책임 정의: "이 객체는 무엇을 해야 하는가?"
2. 인터페이스 설계: "외부에서 어떻게 사용될 것인가?"
3. 협력 관계: "다른 객체와 어떻게 상호작용하는가?"
4. 데이터 결정: "이 행동들을 구현하기 위해 어떤 데이터가 필요한가?"

## 💡 핵심 메시지

"Tell, Don't Ask" 원칙에 따라:

- ❌ "너의 데이터를 달라, 내가 처리할게"
- ✅ "이걸 해줘, 네가 어떻게 하는지는 몰라도 돼"

## 선택 가이드

### 절차지향이 적합한 경우

1. 이벤트성/일회성 작업
2. 데이터 변환/처리 파이프라인(추출, 변환, 로드, 검증)
3. 수학적 계산/알고리즘

### 객체지향이 적합한 경우

1. 상태를 가지고 지속적으로 동작하는 것들
2. 복잡한 비즈니스 규칙이 있는 도메인
3. 다른 곳에서도 사용 가능
4. 새로운 기능 추가가 빈번
5. 내부 구현을 숨겨야 함

### 결론

- 복잡하고 지속적인 것 → 객체지향
- 단순하고 일회적인 것 → 절차지향

## 상속과 컴포지션

### 🧬 상속(Inheritance)이란?

기존 클래스(부모 클래스)의 속성과 메서드를 **새로운 클래스(자식 클래스)**가 물려받는 메커니즘

**기본 개념:**

1. **"is-a" 관계**: "자식은 부모의 한 종류다"
2. **코드 재사용**: 부모의 코드를 다시 작성할 필요 없음
3. **확장**: 부모 기능에 새로운 기능을 추가하거나 수정

**특징:**

1. 자동 획득: 부모의 모든 public/protected 멤버를 자동으로 가짐
2. is-a 관계: Dog is an Animal
3. 다형성 지원
4. 컴파일 시간에 결정: 어떤 클래스를 상속받을지 미리 정해짐

### 🧩 컴포지션(Composition)이란?

다른 클래스의 **객체를 멤버 변수로 가지고**, 그 객체의 기능을 **위임(delegation)**하여 사용하는 방식

**기본 개념:**

1. **"has-a" 관계**: "이 객체는 저 객체를 가지고 있다"
2. **객체 조합**: 여러 객체를 조합해서 새로운 기능 구현
3. **위임**: 다른 객체에게 일을 시킴

**특징:**

1. 명시적 사용: 필요한 기능을 명시적으로 호출
2. has-a 관계: Car has an Engine
3. 유연성: 런타임에 구성 요소 변경 가능
4. 선택적 기능: 필요한 기능만 사용 가능

## 강의 중 재밌었던 부분

> "항상 당신의 코드를 유지보수할 사람이 당신이 어디 사는지 알고 있는 폭력적인 정신병자라고 생각하고 코드를 작성하라"

**코드는 컴퓨터가 아닌 사람을 위해 작성하라!!!!**
