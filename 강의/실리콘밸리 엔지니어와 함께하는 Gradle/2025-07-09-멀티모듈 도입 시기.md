# 멀티모듈 도입 시기

## 멀티모듈이란?

하나의 프로젝트를 여러 개의 독립적인 모듈로 분할하여 관리하는 소프트웨어 개발 방식입니다.

어떤 점이 아쉬워서 해당 기술이 나오게 되었는지도 살펴보자면,

기술적인 필요보다는 **조직적 필요**에서 출발했습니다. (저도 처음에 빌드 시간이 줄이고자 나온 기술이라고 예상했습니다.)

1. 팀 규모 확장 -> 개발자 간 협업 효율성 필요
2. 소프트웨어 복잡도 증가 -> 관리 가능한 단위로 분할 필요
3. 빠른 개발 속도 -> 전체 빌드 없이 부분적 개발 필요
4. 독립적 배포 -> 서비스별 다른 릴리즈 주기 대응

"큰 문제를 작은 문제로 나누어 해결하자"라는 소프트웨어 공학의 기본 원칙을 프로젝트 구조에 적용한 결과입니다.

## 도입 시기

이 글을 쓰게 된 계기에 대해서 글을 써보자 합니다. 소프트웨어 개발은 항상 트레이드 오프의 연속이라고 생각합니다. 어느시기에 멀티모듈을 도입하면 만족스러운 결과를 얻을 수 있는지 정리해보려고 합니다.

무작정 일찍 도입하면 불필요한 복잡성이 증가할 수 있고, 너무 늦으면 리팩토링 비용이 기하급수적으로 늘어날 수 있습니다.

### 단일 모듈의 한계점

#### 1. 빌드 시간의 폭증

```
// 초기 프로젝트 (50개 클래스)
./gradlew build -> 15초

// 6개월 후 (500개 클래스)
./gradlew build -> 1분 30초

// 1년 후 (1500개 클래스)
./gradlew build -> 5분 이상
```

#### 2. 의존성 관리의 혼돈

```java
// 이런 상황이 생긴다면...
@RestController
public class UserController {
    @Autowired
    private OrderRepository orderRepository; // 🚨 왜 User에서 Order를?

    @Autowired
    private PaymentService paymentService; // 🚨 경계가 모호해짐
}
```

#### 3. 팀 간 코드 충돌 증가

```
// Git 히스토리에서 자주 보이는 패턴
- UserService.java (팀 A 수정)
- UserService.java (팀 B 수정)
- UserService.java (팀 C 수정)
→ 매일 merge conflict 발생
```

#### 4. 테스트 실행 시간 급증

```
// 단위 테스트인데 전체 애플리케이션 컨텍스트 로딩
@SpringBootTest
class UserServiceTest {
    // 테스트 하나 실행하는데 30초...
}
```

## 멀티모듈 도입 시점 판단 기준 (클로드 AI 참고)

### 📊 정량적 지표

**1. 코드베이스 크기**

```
✅ 도입 고려: 1,000개 클래스 이상
⚠️ 도입 필수: 2,000개 클래스 이상
🚨 이미 늦음: 5,000개 클래스 이상
```

**2. 빌드 시간**

```
✅ 도입 고려: 전체 빌드 3분 이상
⚠️ 도입 필수: 전체 빌드 5분 이상
🚨 이미 늦음: 전체 빌드 10분 이상
```

**3. 팀 규모**

```
✅ 도입 고려: 개발자 8명 이상
⚠️ 도입 필수: 개발자 15명 이상
🚨 이미 늦음: 개발자 30명 이상
```

### 🔍 정성적 지표

**1. 도메인 경계가 명확해질 때**

```java
// 이런 패키지 구조가 자연스럽게 생겼다면
com.company.app.user
com.company.app.order
com.company.app.payment
com.company.app.notification
```

**2. 팀별 담당 영역이 분리될 때**

```
- 사용자 관리팀 → User 도메인
- 주문 관리팀 → Order 도메인
- 결제팀 → Payment 도메인
- 알림팀 → Notification 도메인
```

**3. 개발자가 전체 코드를 파악하기 어려워질 때**

```
"이 코드가 어디서 쓰이는지 모르겠어요..."
"이 변경이 다른 곳에 영향을 주는지 확신이 안 서요..."
```

## 성급한 멀티모듈화의 부작용

### 🚨 실제 실패 사례

**1. 과도한 모듈 분리**

```
// 초기 프로젝트인데 이렇게 나눴다가...
├── user-api
├── user-service
├── user-repository
├── user-domain
├── user-dto
└── user-utils
```

→ 간단한 기능 하나 추가하는데 6개 모듈 수정

**2. 순환 참조 지옥**

```
user-service → order-service → payment-service → user-service
```

→ 빌드 불가능, 전체 구조 재설계 필요

**3. 과도한 공통 모듈**

```java
// common 모듈이 너무 비대해짐
├── common
│   ├── utils (200개 클래스)
│   ├── constants (50개 클래스)
│   └── exceptions (30개 클래스)
```

→ 모든 모듈이 common에 의존하게 됨

## 마무리

멀티모듈 도입은 **기술적 필요가 아닌 조직적 필요**에 의해 결정되어야 한다.

**골든 타임**:

- 팀이 도메인을 이해하고
- 경계가 명확해졌지만
- 아직 복잡도가 관리 가능한 시점

**기억해야 할 것**:

- 모듈화는 수단이지 목적이 아니다
- 복잡성은 줄이되, 생산성은 높여야 한다
- 팀의 성숙도와 프로젝트 단계를 고려하자
