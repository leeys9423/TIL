# 메모리 누수

## 정의

메모리 누수(Memory Leak)란? 프로그램이 할당받은 메모리를 사용한 뒤 반환하지 않아 더 이상 필요 없는 메모리가 해제되지 않는 현상을 말합니다.

## 메모리 누수가 발생하면 어떤 현상이 일어날까?

1. 성능 저하: 사용되지 않는 메모리가 점유되면서 시스템이 사용할 수 있는 메모리 자원이 줄어들어 전반적인 프로그램 속도가 느려집니다.
2. 프로그램 불안정: 메모리 부족으로 인해 프로그램이 응답하지 않거나, 예기치 않게 강제 종료되는 현상이 발생할 수 있습니다.
3. Out of Memory(OOM): 메모리 누수가 심화되면 시스템이 더 이상 메모리를 할당할 수 없어 `Out of Memory` 오류가 발생하고 프로그램이 중단됩니다.
4. 시스템 리소스 낭비: 불필요한 메모리 점유는 시스템의 귀중한 자원을 낭비하며, 다른 중요한 프로세스가 실행될 공간을 빼앗아갑니다.

### 왜 자바에서도 메모리 누수가 발생할까?

자바에서는 많이 아시다시피 가비지 컬렉션(Garbage Collection)이 존재합니다. 가비지 컬렉션이 자동으로 메모리 관리를 해주기 때문에 대부분의 상황에서는 메모리 누수가 발생하지 않습니다.

그렇다면 어떤 상황에서 메모리 누수가 발생할까요?

개발자가 의도치 않게 객체에 대한 참조를 계속 유지하면 GC는 "아직 사용 중"이라고 판단해서 실제로 더 이상 필요 없는 객체임에도 메모리를 해제하지 않습니다.

도달 가능한(Reachable) 객체라고 표현

### 일부로 OutOfMemoryError 발생시키기

```java
public class OomMain {
    // static 변수 = GC Root! 프로그램 종료 전까지 살아있음
    static List<Data> list = new ArrayList<>();

    public static void main(String[] args) {
        while (true) {
            list.add(new Data()); // 계속 추가만 하고 제거는 안 함
            // list가 계속 참조하고 있어서 GC가 수거 불가능!
        }
    }

    static class Data {

    }
}
```

위와 같이 코드를 짠 이유는 객체가 생성된 후 해당 객체가 가비지 컬렉터의 대상이 되지 않도록 유지시켜야 합니다. 그렇게하기 위해 List를 선언해 무한히 추가하는 식으로 코드를 짰습니다.

위에 결과 바로 OutOfMemoryError가 발생하지는 않았고, 실행하고 어느정도 시간이 지난 뒤 `Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "main"` 이러한 에러 문구를 만날 수 있었습니다.

## 실무에서 만날 수도 있을만한 사례

### 캐시를 무한정 쌓는 경우

```java
private static Map<String, User> userCache = new HashMap<>();

public User getUser(String id) {
    if (!userCache.containsKey(id)) {
        userCache.put(id, fetchFromDB(id));  // 계속 추가만 함
    }
    return userCache.get(id);
}
```
