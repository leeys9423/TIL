# 객체 생명주기와 도달성

## 객체 생명주기(Object Lifecycle)란?

**사전적 의미:**

- 객체가 **생성되어 메모리에 할당**되고, **사용**되다가, **GC에 의해 제거**되는 전체 과정

**왜 중요한가?**

- 객체가 언제 메모리를 차지하고, 언제 해제되는지 알아야 메모리를 효율적으로 관리할 수 있음
- 메모리 누수를 이해하고 예방하는 기초

---

## 도달성(Reachability)란?

**사전적 의미:**

- **GC Root에서 참조 체인을 따라 해당 객체에 도달할 수 있는가?**를 판단하는 기준
- 도달 가능(Reachable) = 살아있음
- 도달 불가능(Unreachable) = GC 대상 (죽음)

**왜 중요한가?**

- GC가 어떤 객체를 제거할지 결정하는 핵심 기준
- 객체 생명주기의 "죽음"을 판단하는 방법

---

## 핵심 연결: 생명주기의 죽음 = 도달 불가능

```
객체 생성 → 사용 중 (도달 가능) → 참조 끊김 (도달 불가능) → GC 수거 → 소멸
                                    ↑
                            이 판단이 "도달성"!
```

**즉:**

- 객체가 **도달 가능**하면 → 살아있음 (사용 중)
- 객체가 **도달 불가능**하면 → 죽음 (GC 대상)

---

## 객체 생명주기의 단계

### 1. Created (생성)

```java
Person p = new Person("홍길동");  // 힙에 Person 객체 생성
```

- 메모리 할당
- 생성자 실행
- 힙 영역에 저장

### 2. In Use (사용 중)

```java
p.sayHello();  // 객체 사용
```

- 도달 가능 상태
- 메서드 호출, 필드 접근 등

### 3. Invisible (보이지 않음)

```java
{
    Person p = new Person("홍길동");
}  // 스코프를 벗어남, p는 더 이상 보이지 않음
   // 하지만 객체는 아직 힙에 존재
```

- 참조 변수는 사라졌지만 객체는 아직 남아있을 수 있음

### 4. Unreachable (도달 불가능)

```java
p = null;  // 참조 끊김 → 도달 불가능
```

- GC Root에서 도달할 수 없음
- GC 대상이 됨

### 5. Collected (수거됨)

- GC가 실행되어 메모리 회수 시작

### 6. Finalized (정리됨)

- finalize() 메서드 실행 (deprecated)

### 7. Deallocated (할당 해제)

- 메모리 완전히 해제
- 재사용 가능한 메모리로 반환

---

## GC Root란?

**정의:**

- GC가 **도달성 검사를 시작하는 출발점**
- 항상 살아있다고 간주되는 참조들

**GC Root의 종류:**

1. **스택의 지역 변수**

```java
public void method() {
    Person p = new Person();  // p는 GC Root
}
```

2. **Static 변수**

```java
public class Example {
    static Person staticPerson = new Person();  // GC Root
}
```

3. **살아있는 스레드**

```java
Thread thread = new Thread();  // thread는 GC Root
```

4. **JNI 참조**

- Native 코드에서 참조하는 객체

---

## 도달성 판단 과정

### 참조 체인(Reference Chain)

```
[GC Root] → [객체A] → [객체B] → [객체C]
                                   ↑
                            모두 도달 가능!

[객체X] → [객체Y]
  ↑
GC Root에서 도달 불가 → GC 대상
```

### 시각화 예제

```java
public class ReachabilityExample {
    static Person staticPerson;  // GC Root

    public static void main(String[] args) {  // main도 GC Root
        Person p1 = new Person("A");  // GC Root (스택)에서 도달 가능
        Person p2 = new Person("B");  // GC Root (스택)에서 도달 가능

        staticPerson = p1;  // A는 static에서도 참조됨

        p2 = null;  // B는 이제 도달 불가능! → GC 대상

        Person p3 = new Person("C");
        p3.friend = new Person("D");  // D는 C를 통해 도달 가능

        p3 = null;  // C와 D 모두 도달 불가능! → GC 대상
    }
}
```

**메모리 상태:**

```
[GC Root: staticPerson] ──→ [Person A] ✅ 도달 가능
[GC Root: main 스택 p1] ───┘

[Person B] ❌ 도달 불가능 (p2 = null)

[Person C] ──→ [Person D]
 ↑ 둘 다 도달 불가능 (p3 = null)
```

---

## 코드로 확인하기

### 예제 1: 생명주기 관찰

```java
public class LifecycleExample {
    public static void main(String[] args) {
        System.out.println("=== 1. 생성 ===");
        Person p = new Person("홍길동");

        System.out.println("\n=== 2. 사용 중 ===");
        p.sayHello();

        System.out.println("\n=== 3. 참조 끊기 ===");
        p = null;  // 도달 불가능

        System.out.println("\n=== 4. GC 요청 ===");
        System.gc();  // GC 실행 요청 (보장되지 않음)

        try {
            Thread.sleep(1000);  // GC 실행 대기
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("\n=== 5. 프로그램 종료 ===");
    }

    static class Person {
        String name;

        Person(String name) {
            this.name = name;
            System.out.println("Person 생성: " + name);
        }

        void sayHello() {
            System.out.println("Hello, I'm " + name);
        }

        @Override
        protected void finalize() throws Throwable {
            System.out.println("Person 소멸: " + name);
        }
    }
}
```

**실행 결과:**

```
=== 1. 생성 ===
Person 생성: 홍길동

=== 2. 사용 중 ===
Hello, I'm 홍길동

=== 3. 참조 끊기 ===

=== 4. GC 요청 ===
Person 소멸: 홍길동

=== 5. 프로그램 종료 ===
```

---

### 예제 2: 도달성 실험

```java
public class ReachabilityTest {
    static List<Person> survivors = new ArrayList<>();  // GC Root

    public static void main(String[] args) {
        // 시나리오 1: 도달 가능한 객체
        Person p1 = new Person("생존자");
        survivors.add(p1);  // static List에 추가 → 계속 도달 가능
        p1 = null;  // 지역 변수는 null이지만, survivors가 참조 중

        // 시나리오 2: 도달 불가능한 객체
        Person p2 = new Person("희생자");
        p2 = null;  // 아무도 참조 안 함 → 도달 불가능

        // 시나리오 3: 순환 참조
        Person p3 = new Person("A");
        Person p4 = new Person("B");
        p3.friend = p4;
        p4.friend = p3;  // 서로 참조

        p3 = null;
        p4 = null;  // GC Root에서 도달 불가능하면 순환 참조여도 GC 대상!

        System.gc();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("살아남은 객체: " + survivors.size());
    }

    static class Person {
        String name;
        Person friend;

        Person(String name) {
            this.name = name;
            System.out.println("Person 생성: " + name);
        }

        @Override
        protected void finalize() throws Throwable {
            System.out.println("Person 소멸: " + name);
        }
    }
}
```

---

## 이전 키워드와의 연결

### 메모리 누수와의 관계

```java
public class MemoryLeakExample {
    static List<Person> list = new ArrayList<>();  // GC Root

    public void method() {
        Person p = new Person("누수 대상");
        list.add(p);  // static List에 추가
    }  // method 종료
       // 스택의 p는 사라지지만
       // 힙의 Person 객체는 list가 참조 중 → 계속 도달 가능
       // → 메모리 누수!
}
```

**핵심:**

- **의도치 않게 도달 가능 상태를 유지** → 메모리 누수
- 실제로는 사용 안 하는데 참조만 유지 → GC가 회수 못 함

---

### 힙/스택과의 관계

**핵심:**

- 스택과 메서드 영역이 **GC Root**
- 힙의 객체는 GC Root에서의 **도달성**으로 생사 결정
- 스택/메서드 영역의 참조가 끊기면 → 도달 불가능 → GC 대상
