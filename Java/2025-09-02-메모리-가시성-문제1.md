# 메모리 가시성 문제 1

메모리 가시성(Memory Visibility) 문제란 멀티 스레드 환경에서 발생하는 **특정 스레드에서 변경한 정보**가 바로 **다른 스레드에 보이지 않은 현상**입니다.

이 문제를 이해하기 위해서 먼저 JVM(Java Virtual Machine)과 하드웨어 메모리 구조를 살펴보는 것이 이해에 도움이 될 것입니다.

## JVM 메모리 구조

### 메인 메모리 (Main Memory)

- 모든 스레드가 공유하는 영역
- 힙(Heap), 메서드 영역(Method Area) 등
- 실제 변수의 "진짜 값"이 저장되는 곳

### 스레드별 작업 메모리 (Working Memory)

- 각 스레드마다 독립적으로 가지는 메모리 공간
- CPU 캐시, 레지스터 등에 해당
- 성능을 위해 메인 메모리의 값을 복사해서 사용

## 하드웨어 메모리 구조

### 하드웨어 메모리 계층

```
CPU 레지스터 (가장 빠름)
    ↓
L1 캐시 (스레드별 독립)
    ↓
L2 캐시 (코어별)
    ↓
L3 캐시 (CPU별 공유)
    ↓
메인 RAM (가장 느림, 모든 스레드 공유)
```

> ![메모리 구조](/image/memory-structure.png)
> 출처: https://jenkov.com/images/java-concurrency/cpu-cache-coherence-and-java-concurrency-1.png

## JVM과 하드웨어 메모리의 관계

**JVM의 작업 메모리**는 실제로 하드웨어의 **레지스터, L1/L2 캐시** 등에 매핑됩니다.

**JVM의 메인 메모리**는 실제로 하드웨어의 **RAM**에 매핑됩니다.

메모리 가시성 문제는 이 JVM **작업 메모리**와 **메인 메모리** 간의 **동기화 지연 때문에 발생**하는 논리적 문제라고 생각하면 됩니다.

> 캐시 일관성 외에 쓰기 버퍼링(Write Buffering)이 문제가 될 수 있다.
>
> 쓰기 버퍼링(Write Buffering)란?
>
> - CPU는 성능을 위해 쓰기 작업을 즉시 메인 메모리에 반영하지 않음
> - 쓰기 버퍼에 모아뒀다가 적절한 시점에 일괄처리
> - 다른 스레드는 이 변경사항을 모름

자 이제 문제에 대한 원인을 알았으니, 해결방법에 대해서도 알아봅시다.

## 메모리 가시성 해결방법

### volatile

자바에서 지원하는 `volatile`이라는 키워드를 사용하여 해결할 수 있습니다.

- volatile 키워드는 변수를 "**메인 메모리**에 저장하겠다."라고 명시하는 것입니다.
- 변수의 값을 읽을 때마다 CPU cache에 저장된 값이 아닌, **메인 메모리**에서 읽는 것입니다.

즉, 정리하자면 메인 메모리는 실제 하드웨어의 RAM에 매핑되는 영역이며 스레드별로 공유가 되는 영역입니다. 그러므로 `volatile` 키워드를 가지고 있는 변수들은 모든 스레드가 공평하게, 동일한 최신 값에 접근할 수 있도록 보장하는 것입니다.

해당 키워드로 모든 스레드가 접근하여 똑같은 값을 가져오는 읽어오는 것에 대해서는 문제가 없을 것입니다. 하지만 **쓰기 작업**이 일어난다고 했을 때, 예를 들어 A스레드와 B스레드가 동시에 RAM에 있는 변수를 수정하려고 할 때 문제가 야기됩니다.

이를 해결하기 위한 방법도 알아봅시다.

### synchronized

위에서 언급한 문제를 경쟁 상태(Race Condition)이라고 불립니다.

#### 경쟁 상태(Race Condition)이란?

두 개 이상의 스레드 또는 프로세스가 공유 자원에 동시에 접근하고 수정을 시도할 때 발생할 수 있는 문제입니다.

#### 상호 배제(Mutual Exclusion)

이 문제를 해결하기 위해 두 개 이상의 스레드 또는 프로세스가 공용 데이터에 **동시에 접근을 하는 것을 막아야 합니다**. 즉, 한 스레드나 프로세스가 공용 데이터를 사용하고 있으면 그 자원을 사용하지 못하도록 막거나, 다른 프로세스가 그 자원을 사용하지 못하도록 막으면 이 문제를 피할 수 있습니다. 이것은 **상호 배제**(Mutual Exclusion)이라고 부릅니다.

#### 교착 상태(Deadlock)

두 개 이상의 프로세스가 서로 상대방이 점유하고 있는 자원을 필요로 하여, 서로의 작업이 완료되기를 **무한정 기다리며 아무것도 처리하지 못하는 상태**를 **교착 상태**(Deadlock)이라고 부릅니다.

#### 기아 상태(Starvation)

특정 프로세스나 스레드가 자원을 할당받지 못해 작업을 무한히 대기하는 상태를 의미합니다.

#### 교착 상태와 기아 상태의 차이

교착 상태는 여러 프로세스가 **서로의 자원**을 기다리는 상황이지만, 기아 상태는 한 프로세스가 **자원을 얻기 위해** 무한히 기다리는 상태입니다.

#### 경쟁 상태(Race Condition)의 해결 방법

경쟁 상태의 해결 방법에는 **세마포어**(Semaphore)와 **뮤텍스**(Mutex)를 사용하여 해결합니다.(해당 내용은 운영체제 카테고리에서 다시 다루겠습니다.)

다시 `synchronized`로 돌아와서 해당 키워드는 동기화가 필요한 메서드나 코드블럭 앞에 사용하여 동기화 할 수 있습니다.
`synchronized`로 지정된 **임계영역**은 한 스레드가 이 영역에 접근하여 사용할 때 **lock**을 사용함으로써, 다른 스레드가 접근할 수 없게 됩니다. 이후 해당 스레드가 이 임계영역의 코드를 다 실행하게되면 **unlock** 상태가 되어 대기하고 있던 다른 스레드가 사용할 수 있게 됩니다.

`synchronized`도 한계가 존재하는데, 해당 한계와 해결하는 방법은 다음 글에서 다뤄보도록 하겠습니다.
