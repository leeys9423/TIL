# 상속 (Inheritance)

## 상속이란?

### 개념

상속(Inheritance)은 기존 클래스(부모 클래스, 슈퍼 클래스)의 속성과 메서드를 새로운 클래스(자식 클래스, 서브 클래스)가 물려받는 객체지향 프로그래밍의 핵심 개념이다.

### 현실 세계 비유

```
동물 🐾
├── 이름, 나이, 먹기(), 잠자기()
├── 강아지 🐕 extends 동물
│   ├── (상속) 이름, 나이, 먹기(), 잠자기()
│   └── (추가) 품종, 짖기()
└── 고양이 🐱 extends 동물
    ├── (상속) 이름, 나이, 먹기(), 잠자기()
    └── (추가) 털색, 야옹거리기()
```

### 기본 문법

```java
// 부모 클래스
class Animal {
    protected String name;
    protected int age;

    public void eat() {
        System.out.println("음식을 먹습니다.");
    }
}

// 자식 클래스
class Dog extends Animal {
    private String breed;

    public void bark() {
        System.out.println("멍멍!");
    }
}
```

## 상속을 쓰는 이유

### 1. 코드 재사용성 (Code Reusability)

```java
// 상속 없이
class Dog {
    String name;
    int age;
    void eat() { /* 동일한 코드 */ }
    void sleep() { /* 동일한 코드 */ }
    void bark() { /* 고유 코드 */ }
}

class Cat {
    String name;    // 중복!
    int age;        // 중복!
    void eat() { /* 동일한 코드 - 중복! */ }
    void sleep() { /* 동일한 코드 - 중복! */ }
    void meow() { /* 고유 코드 */ }
}

// 상속 사용
class Animal {
    String name;
    int age;
    void eat() { /* 공통 코드 */ }
    void sleep() { /* 공통 코드 */ }
}

class Dog extends Animal {
    void bark() { /* 고유 코드만 */ }
}

class Cat extends Animal {
    void meow() { /* 고유 코드만 */ }
}
```

### 2. 유지보수성 향상

```java
// Animal 클래스의 eat() 메서드를 수정하면
// Dog, Cat 등 모든 자식 클래스에 자동으로 반영됨
public void eat() {
    System.out.println(name + "이(가) 맛있게 먹고 있습니다."); // 한 번만 수정
}
```

### 3. 다형성(Polymorphism) 구현

하나의 인터페이스로 여러 타입의 객체를 동일하게 다룰 수 있는 능력을 제공

```java
Animal[] animals = {new Dog(), new Cat(), new Bird()};

for (Animal animal : animals) {
    animal.eat();  // 각각 다른 구현체이지만 같은 인터페이스로 호출
}
```

## 상속의 장단점

### 장점 ✅

**1. 코드 재사용성**

- 공통 기능을 한 번만 구현
- 개발 시간 단축

**2. 유지보수성**

- 공통 로직 변경 시 한 곳만 수정
- 버그 수정이 모든 자식 클래스에 반영

**3. 확장성**

- 기존 코드 수정 없이 새로운 기능 추가 가능
- 점진적 개발 가능

**4. 다형성 지원**

- 같은 인터페이스로 다양한 객체 다룰 수 있음

### 단점 ❌

**1. 강한 결합도(Tight Coupling)**

```java
class Vehicle {
    private int fuel;  // private로 변경하면
}

class Car extends Vehicle {
    public void drive() {
        // fuel에 접근 불가! 자식 클래스가 영향받음
        // System.out.println(fuel);  // 컴파일 에러
    }
}
```

**2. 복잡성 증가**

```java
// 깊은 상속 계층
class A { }
class B extends A { }
class C extends B { }
class D extends C { }  // 너무 깊어서 이해하기 어려움
```

**3. 유연성 제한**

```java
// 자바는 단일 상속만 지원
class FlyingCar extends Car, Airplane { }  // 불가능!
```

**4. 잘못된 추상화**

- 적절하지 않은 상속 계층 설계 시 발생
- 일부 자식 클래스에서 불필요한 기능을 강제로 상속받게 됨
- LSP(리스코프 치환 원칙) 위반 가능성

## 추상화 (Abstraction)

### 개념

추상화는 공통된 특성을 뽑아내어 하나로 묶는 것. 상속과 밀접한 관련이 있다.

### 추상 클래스 활용

```java
// 추상 클래스 - 직접 인스턴스화 불가
abstract class Shape {
    protected String color;

    // 일반 메서드 - 공통 기능
    public void setColor(String color) {
        this.color = color;
    }

    // 추상 메서드 - 자식 클래스에서 반드시 구현
    public abstract double calculateArea();
    public abstract void draw();
}

// 구체 클래스
class Circle extends Shape {
    private double radius;

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public void draw() {
        System.out.println(color + " 원을 그립니다.");
    }
}

class Rectangle extends Shape {
    private double width, height;

    @Override
    public double calculateArea() {
        return width * height;
    }

    @Override
    public void draw() {
        System.out.println(color + " 사각형을 그립니다.");
    }
}
```

### 추상화의 이점

```java
// 클라이언트 코드는 구체적인 구현을 몰라도 됨
Shape[] shapes = {new Circle(), new Rectangle()};

for (Shape shape : shapes) {
    shape.setColor("빨강");     // 공통 메서드
    shape.draw();              // 각각 다른 구현
    System.out.println("면적: " + shape.calculateArea());
}
```

## 결합도 (Coupling)

### 강한 결합도의 문제

```java
// 나쁜 예 - 강한 결합
class Engine {
    public void start() {
        System.out.println("엔진 시동");
    }
}

class Car extends Engine {  // 상속으로 강하게 결합
    public void drive() {
        start();  // Engine에 의존
    }
}

// Engine 클래스가 변경되면 Car도 영향받음
// Car는 항상 Engine의 모든 기능을 상속받아야 함
```

### 약한 결합도로 개선

```java
// 좋은 예 - 컴포지션 사용으로 약한 결합
class Engine {
    public void start() {
        System.out.println("엔진 시동");
    }
}

class Car {
    private Engine engine;  // 컴포지션

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();  // 위임
    }
}

// 사용
Car car = new Car(new Engine());
Car electricCar = new Car(new ElectricEngine());  // 다른 엔진도 사용 가능
```

### 결합도를 낮추는 방법

**1. 인터페이스 활용**

```java
interface Drivable {
    void drive();
}

class Car implements Drivable {
    public void drive() { /* 구현 */ }
}

class Motorcycle implements Drivable {
    public void drive() { /* 구현 */ }
}
```

**2. 컴포지션 선호**

```java
// "has-a" 관계는 컴포지션으로
class Car {
    private Engine engine;    // Car has an Engine
    private Wheel[] wheels;   // Car has Wheels
}

// "is-a" 관계만 상속으로
class SportsCar extends Car {  // SportsCar is a Car
}
```

## 실무 팁

### 언제 상속을 사용할까?

- **is-a 관계**가 명확할 때: "강아지는 동물이다"
- **공통 기능이 많을 때**: 코드 중복을 줄일 수 있음
- **확장이 필요할 때**: 기존 기능을 유지하면서 새 기능 추가

### 언제 상속을 피해야 할까?

- **has-a 관계**일 때: "자동차는 엔진을 가진다" → 컴포지션 사용
- **기능만 빌려쓰고 싶을 때**: 인터페이스나 컴포지션 고려
- **불필요한 기능까지 상속**되는 경우

### 대안들

1. **인터페이스**: 다중 구현 가능, 약한 결합
2. **컴포지션**: 런타임에 동작 변경 가능
3. **델리게이션**: 기능을 다른 객체에 위임
