# 서버 네트워크 통신 기초

## 서버(Server)란?

서버는 다른 프로그램(클라이언트)의 요청을 받아 서비스를 제공하는 **역할을 하는 프로그램**이다. 하나의 컴퓨터에서도 여러 개의 서버 프로그램이 동시에 실행될 수 있다.

### 실생활 비유로 이해하기

- **레스토랑**: 손님(클라이언트)이 주문하면, 주방(서버)에서 요리를 만들어 제공
- **은행**: 고객(클라이언트)이 업무를 요청하면, 은행 시스템(서버)에서 처리 후 결과 제공
- **도서관**: 이용자(클라이언트)가 책을 요청하면, 사서(서버)가 찾아서 제공

### 서버의 핵심 특징

1. **대기 상태**: 항상 클라이언트의 요청을 기다림
2. **요청 처리**: 받은 요청을 분석하고 적절한 응답 생성
3. **동시성**: 여러 클라이언트를 동시에 처리할 수 있어야 함

## 소켓 통신이란?

네트워크 프로그래밍에서 **소켓(Socket)**은 통신의 끝점이다.(혹은 전송계층(4계층)과 세션계층(5계층) 사이에 위치하는 인터페이스) 전화기에 전화선을 꽂는 잭(jack)을 생각하면 이해하기 쉽다.

### TCP vs UDP - 언제 무엇을 사용할까?

**TCP (Transmission Control Protocol)**

- **연결 기반**: 통신 전에 반드시 연결 설정
- **신뢰성 보장**: 데이터 순서, 무결성 보장
- **사용 예시**: 웹 브라우징, 이메일, 파일 다운로드
- **트레이드오프**: 안전하지만 상대적으로 느림

**UDP (User Datagram Protocol)**

- **비연결**: 연결 과정 없이 바로 데이터 전송
- **속도 우선**: 빠르지만 데이터 손실 가능성
- **사용 예시**: 실시간 게임, 라이브 스트리밍, DNS 조회
- **트레이드오프**: 빠르지만 데이터 손실 위험

### 소켓 프로그래밍의 기본 흐름

**서버 프로그램의 생명주기:**

```
1. socket() - 소켓 생성
2. bind() - IP주소와 포트 번호 바인딩
3. listen() - 클라이언트 연결 대기
4. accept() - 클라이언트 연결 수락
5. send/recv() - 데이터 송수신
6. close() - 연결 종료
```

**클라이언트 프로그램은 더 간단하다:**

```
1. socket() - 소켓 생성
2. connect() - 서버에 연결 요청
3. send/recv() - 데이터 송수신
4. close() - 연결 종료
```

## 커넥션(Connection)이란?

커넥션은 클라이언트와 서버 간의 **논리적인 통신 경로**다. 물리적으로는 인터넷의 복잡한 라우터들을 거치지만, 프로그래머 입장에서는 직접 연결된 것처럼 보인다.

### TCP 3-Way Handshake

TCP 연결이 어떻게 설정되는지 이해하면 커넥션의 개념이 명확해진다:

```
클라이언트 ----SYN-----> 서버     "연결하고 싶습니다"
클라이언트 <--SYN+ACK--- 서버     "저도 연결할게요"
클라이언트 ----ACK-----> 서버     "확인했습니다"
```

이 과정이 완료되면 **안정적인 커넥션**이 생성된다.

### 커넥션 관리의 중요성

현실에서는 커넥션을 생성하고 해제하는 비용이 크다. 따라서:

- **커넥션 풀링**: 미리 연결을 만들어두고 재사용
- **Keep-Alive**: HTTP에서 한 번 연결로 여러 요청 처리
- **타임아웃 관리**: 사용하지 않는 연결은 자동으로 정리

웹 브라우저가 하나의 웹페이지를 로드할 때 HTML, CSS, JS, 이미지 등 수십 개의 파일을 요청하는데, 매번 새로운 연결을 만든다면 매우 비효율적이다.

## 실제 웹 통신 예시로 종합 이해

브라우저에서 `https://www.google.com`을 입력했을 때 일어나는 일:

### 1단계: DNS 조회 (UDP)

```
브라우저 → DNS 서버: "www.google.com의 IP 주소가 뭐야?"
DNS 서버 → 브라우저: "142.250.xxx.xxx야"
```

### 2단계: TCP 커넥션 설정

```
브라우저 → 구글서버(443포트): SYN
브라우저 ← 구글서버: SYN+ACK
브라우저 → 구글서버: ACK
```

### 3단계: HTTPS 핸드셰이크

- TCP 위에 TLS/SSL 보안 계층 추가
- 암호화 키 교환

### 4단계: HTTP 요청/응답

```
브라우저 → 구글서버: "GET / HTTP/1.1"
브라우저 ← 구글서버: "HTTP/1.1 200 OK + HTML 내용"
```

### 5단계: 커넥션 관리

- HTTP/1.1: Keep-Alive로 연결 유지
- HTTP/2: 하나의 연결로 여러 요청 동시 처리
