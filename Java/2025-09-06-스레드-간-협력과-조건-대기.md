# 스레드 간 협력과 조건 대기

`synchronized`는 한 번에 하나의 스레드만 접근을 허용하여 `Race Condition`을 방지합니다. 하지만 때로는 스레드들이 서로 협력해야 하는 상황이 있습니다.

예를 들어

1. 생산자가 데이터를 만들면, 소비자에게 "준비됐다"고 알려줘야 함
2. 버퍼가 가득 찬 경우, 생산자는 대기해야 함
3. 버퍼가 비어있는 경우, 소비자는 대기해야 함

이런 상황에서는 단순한 배타적 접근만으로는 해결할 수 없습니다. `synchronized`로 락을 잡고 있는 스레드가 특정 조건을 기다려야 한다면, 다른 스레드들은 그 조건을 만족시킬 기회조차 얻을 수 없게 됩니다.

## wait(), notify(), notifyAll() 개념

스레드 간 협력을 위해 Object 클래스의 wait(), notify(), notifyAll() 메서드를 사용하면 됩니다.

- wait(): 현재 스레드를 대기 상태로 만들고 락을 해제
- notify(): 대기 중인 스레드 중 하나를 깨움
- notifyAll(): 대기 중인 모든 스레드를 깨움

### 중요한 규칙

1. 반드시 `synchronized` 블록/메서드 안에서 사용 가능
2. 같은 객체의 모니터를 가지고 있어야 함

이 규칙들을 지키지 않으면 `IllegalMonitorStateException`이 발생합니다.

### 모니터(Monitor)란?

모니터는 **공유 자원에 대한 접근을 제어**하는 동기화 메커니즘입니다.

#### Java에서의 모니터

```java
// 모든 Java 객체는 모니터를 가지고 있음
Object obj = new Object();  // 이 객체도 모니터를 가짐

synchronized (obj) {        // obj의 모니터를 획득
    // 임계 영역
}                          // obj의 모니터를 해제
```

#### 모니터의 구조

1. **뮤텍스**(락) - 한 번에 하나의 스레드만 접근 허용
2. **조건 변수** - wait/notify를 위한 대기 큐
3. **집입 큐** - 모니터에 들어가려고 대기하는 스레드들

```
모니터 (Monitor)
    뮤텍스 (락)
    ├─ 현재 소유자: Thread A
    └─ 상태: 잠김/해제됨
    조건 변수 (Wait Set)
    ├─ 대기 중인 스레드들
    └─ wait() 호출한 스레드들
    진입 큐 (Entry Set)
    └─ 모니터 진입 대기 스레드들
```

모니터에 대해서 간략하게 알아봤으니, 다시 돌아가서 동작 메커니즘에 대해서 설명드리겠습니다.

### 동작 메커니즘

```java
synchronized (sharedObject) {
    // 1. 현재 스레드가 sharedObject의 락을 가지고 있음

    while (조건이 만족되지 않음) {
        sharedObject.wait();  // 2. 락을 놓고 대기 상태로 들어감
                              // 3. 다른 스레드가 락을 획득할 수 있게 됨
    }

    // 4. notify()를 받고 깨어나면 다시 락을 획득하고 조건을 재확인
    // 5. 조건이 만족되면 작업 수행
}
```

위의 메커니즘을 토대로한 생산자-소비자 패턴에 대한 예시 코드는 다음과 같습니다.

### 실제 예제: Producer-Consumer 패턴

**시나리오:**

- 생산자(Producer): 데이터를 만들어서 버퍼에 저장
- 소비자(Consumer): 버퍼에서 데이터를 가져와서 처리
- 버퍼 크기 제한: 가득 찬 경우 생산자 대기, 비어있는 경우 소비자 대기

```java
import java.util.LinkedList;
import java.util.Queue;

public class ProducerConsumerExample {
    private final Queue<Integer> buffer = new LinkedList<>();
    private final int BUFFER_SIZE = 5;

    // 생산자 메서드
    public void produce(int data) throws InterruptedException {
        synchronized (buffer) {
            // 버퍼가 가득 찰 때까지 대기
            while (buffer.size() == BUFFER_SIZE) {
                System.out.println("Producer: 버퍼가 가득참, 대기 중...");
                buffer.wait();
            }

            // 데이터 생산
            buffer.offer(data);
            System.out.println("Producer: " + data + " 생산됨, 버퍼 크기: " + buffer.size());

            // 소비자들에게 알림
            buffer.notifyAll();
        }
    }

    // 소비자 메서드
    public int consume() throws InterruptedException {
        synchronized (buffer) {
            // 버퍼가 비어있을 때까지 대기
            while (buffer.isEmpty()) {
                System.out.println("Consumer: 버퍼가 비어있음, 대기 중...");
                buffer.wait();
            }

            // 데이터 소비
            int data = buffer.poll();
            System.out.println("Consumer: " + data + " 소비됨, 버퍼 크기: " + buffer.size());

            // 생산자들에게 알림
            buffer.notifyAll();
            return data;
        }
    }

    public static void main(String[] args) {
        ProducerConsumerExample example = new ProducerConsumerExample();

        // 생산자 스레드
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 10; i++) {
                    example.produce(i);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        // 소비자 스레드
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 10; i++) {
                    example.consume();
                    Thread.sleep(150);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        producer.start();
        consumer.start();

        try {
            producer.join();
            consumer.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

### notify() vs notifyAll()

#### notify()

- 동작: 대기 중인 스레드 중 하나만 깨움
- 선택: 어떤 스레드가 깨어날지 예측 불가 (JVM이 결정)
- 장점: 성능상 유리 (하나의 스레드만 깨움)
- 단점: 잘못된 스레드가 깨어날 위험

#### notifyAll()

- 동작: 대기 중인 모든 스레드를 깨움
- 결과: 모든 스레드가 조건을 재확인하고 적절한 스레드만 진행
- 장점: 안전함, 데드락 위험 낮음
- 단점: 불필요한 스레드들도 깨워서 성능 저하 가능

#### 선택 가이드

- 불확실하면 notifyAll() 사용 (안전함이 우선)
- 성능이 중요하고 조건이 단순하면 notify() 고려
- 여러 종류의 스레드가 다른 조건을 기다리면 notifyAll() 필수

### 실제 사용처

1. 웹 서버 - 요청 처리 큐 (백프레셔)
2. 데이터베이스 커넥션 풀
3. 배치 처리 시스템
4. 게임 서버 - 턴 기반 게임
5. 파일 업로드/다운로드 - 대역폭 제어
6. 실시간 데이터 처리 - 스트리밍
