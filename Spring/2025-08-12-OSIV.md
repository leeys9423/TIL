# OSIV와 @Transactional

## 용어 정의

### 영속성 컨텍스트 (Persistence Context)

엔티티를 영구 저장하는 환경으로, 논리적인 개념입니다. EntityManager를 통해 접근할 수 있으며, 엔티티의 생명주기를 관리하는 1차 캐시 역할을 합니다.

### OSIV (Open Session In View)

영속성 컨텍스트를 뷰(또는 REST API에서는 HTTP 응답 완료)까지 열어두는 기능. Spring Boot에서는 기본값이 `true`로 설정되어 있다.

### 트랜잭션 (Transaction)

데이터베이스에 변경사항을 실제로 반영하는 작업 단위. 커밋 시점에 flush가 호출되어 실제 SQL이 실행된다.

## 내가 헷갈렸던 부분

### "영속성 컨텍스트가 뷰까지 지속되는데 왜 변경감지가 안되지?"

처음에는 영속성 컨텍스트에 엔티티가 들어가 있으면 변경감지(Dirty Checking)가 자동으로 데이터베이스에 반영될 것이라고 생각했습니다.

```java
@GetMapping("/api/members/{id}")
public String updateMember(@PathVariable Long id) {
    Member member = memberService.findOne(id); // 영속성 컨텍스트에 로드됨
    member.setName("변경된 이름"); // 변경감지 발생하지만...
    // UPDATE 쿼리가 실행되지 않음!
    return "updated";
}
```

**왜 안되는가?**

- 영속성 컨텍스트는 변경사항을 "감지"만 할 뿐
- 실제 데이터베이스 반영은 트랜잭션 커밋 시점에 flush를 통해 이루어짐
- OSIV로 영속성 컨텍스트는 살아있지만, 서비스 메서드가 끝나면서 트랜잭션은 이미 종료됨

### REST API에서 "뷰까지 간다"는 표현의 괴리감

요즘은 REST API를 많이 사용하고, 컨트롤러 레이어에서 엔티티를 직접 조작하는 일이 거의 없었기 때문에 OSIV의 개념을 체감하기 어려웠습니다.

**실제로는** REST API 환경에서는 JSON 직렬화 과정까지 영속성 컨텍스트가 유지된다는 의미였습니다.

## 내가 OSIV를 몰랐던 이유

평소에 서비스 레이어에서 엔티티를 DTO로 변환해서 반환하는 패턴을 사용했기도 했고, 위에서 얘기했듯 컨트롤러에서 엔티티를 직접 조작하는 일이 없었기 때문입니다.

```java
// 내가 주로 사용하던 패턴
@Service
@Transactional(readOnly = true)
public class MemberService {

    public MemberDto findMember(Long id) {
        Member member = memberRepository.findById(id);
        // 트랜잭션 안에서 DTO 변환
        return new MemberDto(member.getName(), member.getEmail());
    }
}

@RestController
public class MemberController {

    @GetMapping("/api/members/{id}")
    public MemberDto getMember(@PathVariable Long id) {
        // 이미 DTO로 변환되어서 넘어옴
        return memberService.findMember(id);
    }
}
```

이 패턴에서는:

- 서비스 레이어에서 필요한 데이터를 모두 추출해서 DTO로 변환
- 컨트롤러에는 순수한 DTO만 넘어옴
- 지연로딩이나 영속성 컨텍스트와 관련된 문제가 발생하지 않음

그래서 OSIV의 필요성이나 문제점을 체감하지 못했었습니다.

## OSIV의 단점

DTO 패턴을 사용함으로써 자연스럽게 회피했던 OSIV의 단점들이 있습니다.

### 긴 DB 커넥션 점유

OSIV가 켜져 있으면 API 응답이 완료될 때까지 데이터베이스 커넥션을 반환하지 않을 수 있다. 이는 실시간 트래픽이 많은 서비스에서는 심각한 장애로 이어질 수 있다.

```java
@GetMapping("/api/members/{id}")
public MemberResponse getMember(@PathVariable Long id) {
    Member member = memberService.findOne(id);
    // 여기서부터 JSON 직렬화 완료까지 커넥션 점유 지속
    return new MemberResponse(member);
}
```

### N+1 문제 발생 가능성

DTO 변환 없이 컨트롤러나 뷰(템플릿 엔진)에서 지연 로딩(Lazy Loading)된 연관 엔티티를 조회할 때, 의도치 않은 N+1 쿼리가 발생하기 쉽습니다.

```java
// 위험한 패턴: 컨트롤러에서 엔티티 직접 사용
@GetMapping("/api/members")
public List<MemberResponse> getMembers() {
    List<Member> members = memberService.findAll(); // 1번의 쿼리
    return members.stream()
            .map(member -> new MemberResponse(
                member.getName(),
                member.getOrders().size() // N번의 추가 쿼리 발생!
            ))
            .collect(toList());
}
```

## 결론

OSIV의 핵심은 **언제까지 영속성 컨텍스트를 유지할 것인가**의 문제입니다. 엔티티를 직접 컨트롤러나 뷰로 전달하는 경우에만 OSIV의 장단점이 드러나고, DTO 변환 패턴을 사용하면 OSIV의 영향을 거의 받지 않습니다.
