# 의존성 주입 방식 비교: 생성자 주입 vs 필드 주입

자바 스프링을 공부하면서 의존성 주입(DI)의 세 가지 방식(생성자 주입, 세터 주입, 필드 주입) 중에서 생성자 주입과 필드 주입의 차이점을 테스트 코드를 작성해보며 장단점을 파악해 보겠습니다.

## 필드 주입

필드 주입이란? `@Autowired` 어노테이션을 사용하여 Spring 컨테이너에 등록된 빈을 인스턴스 변수에 자동으로 주입해주는 방식입니다.

```java
@Service
public class PayService {
    @Autowired
    private PaymentRepository paymentRepository;

    public void processPayment(String userId, int amount) {
        Payment payment = new Payment(userId, amount);
        paymentRepository.save(payment);
    }
}
```

### 동작 방식

1. Spring이 PayService 객체를 생성 (이때 paymentRepository는 null)
2. Spring 컨테이너가 `@Autowired` 어노테이션을 발견
3. 컨테이너에서 PaymentRepository 타입의 빈을 검색
4. Reflection을 사용하여 private 필드에 접근
5. 찾은 빈의 참조를 필드에 주입

## 생성자 주입

생성자 주입은 클래스의 생성자를 통해 의존성을 주입받는 방식입니다.

```java
@Service
public class PayService {
    private final PaymentRepository paymentRepository;
    
    public PayService(PaymentRepository paymentRepository) {
        this.paymentRepository = paymentRepository;
    }
    
    public void processPayment(String userId, int amount) {
        Payment payment = new Payment(userId, amount);
        paymentRepository.save(payment);
    }
}
```

### 동작 방식

1. Spring 컨테이너가 PayService 빈을 생성하기 전에 필요한 의존성을 먼저 확인
2. PaymentRepository 타입의 빈을 컨테이너에서 찾음
3. 찾은 빈을 생성자의 파라미터로 전달하여 PayService 객체 생성
4. 생성자 실행과 동시에 의존성이 주입되어 객체 생성 완료

### 두 방식의 차이점

- 필드 주입: 객체 생성 후 -> Reflection으로 필드에 주입
- 생성자 주입: 의존성 준비 후 -> 객체 생성과 동시에 주입

**생성자 주입의 이점:**
- 객체 생성 시점에 모든 의존성이 보장됨
- final 키워드 사용 가능 (불변성 보장)
- Spring 없이도 `new PayService(repository)` 형태로 직접 생성 가능

## 테스트에서의 차이

위에서 언급한 방식의 차이점을 살펴보면, 필드 주입 시 Spring 컨테이너가 Reflection을 통해 인스턴스 변수에 빈을 주입해주었습니다.

이로 인해, 필드 주입은 Spring 컨테이너에 종속적이라고 할 수 있습니다. 그래서 필드 주입을 사용한 코드들은 `@SpringBootTest` 어노테이션을 활용하여 Spring 컨테이너 환경에서만 테스트가 가능해집니다. 여기서 파생되는 문제점을 짚어보고자 합니다.

### @SpringBootTest의 문제점

1. Spring 프레임워크에 강하게 의존되어 있음 (단위테스트가 불가능)
    - Spring 컨테이너 없이는 필드 주입을 받는 필드는 null입니다. 이로 인해 순수히 기능 테스트에 집중하기 어려움
    - `필드 주입을 받는 필드의 접근 제어자를 public으로 열고, 세팅해주면 되지 않을까?`라는 생각도 해보았지만 이렇게 되면 캡슐화도 깨질 뿐더러, 불변성을 보장하지도 않고, 런타임에 의도하지 않게 수정이 가능하게 되어 문제를 야기하는 코드가 됩니다.
2. Spring 컨테이너 부팅 시간으로 인해 테스트가 많아질수록 테스트가 느려짐

### 생성자 주입 시 테스트에서의 이점

위에 언급된 내용과 반대인 점이 이점이 됩니다.

1. Spring에 의존적이지 않으며, 단위테스트가 가능해집니다.
    - 가짜 객체를 주입하여 기능에 집중한 테스트를 작성할 수 있게 됩니다.
2. 테스트 실행시간이 매우 짧아짐

### 테스트 코드 비교

**필드 주입 방식**
```java
@SpringBootTest  // Spring 컨테이너를 띄워야 함
class PayServiceTest {
    
    @Autowired
    private PayService payService;
    
    @MockBean  // Spring 컨테이너에 Mock 빈 등록
    private PaymentRepository paymentRepository;
    
    @Test
    void processPayment_테스트() {
        // given
        when(paymentRepository.findById(1L))
            .thenReturn(new Payment(1L, "user1", 10000));
        
        // when & then
        payService.processPayment("user1", 10000);
    }
}
```

**생성자 주입 방식**

생성자 주입은 각 테스트마다 수동으로 객체를 주입해야 하는 번거로움이 있지만, `@BeforeEach`를 활용하면 반복을 줄일 수 있다.

```java
class PayServiceTest {
    
    @Test
    void processPayment_Fake객체_사용() {
        // given
        PaymentRepository fakeRepository = new FakePaymentRepository();
        PayService payService = new PayService(fakeRepository);
        
        // when
        payService.processPayment("user1", 10000);
        Payment payment = payService.getPayment(1L);
        
        // then
        assertNotNull(payment);
        assertEquals("user1", payment.getUserId());
        assertEquals(10000, payment.getAmount());
    }
}

// Fake 구현체
class FakePaymentRepository implements PaymentRepository {
    private Map storage = new HashMap<>();
    
    @Override
    public void save(Payment payment) {
        storage.put(payment.getId(), payment);
    }
    
    @Override
    public Payment findById(Long id) {
        return storage.get(id);
    }
}
```

## 결론

Spring 공식 문서에서도 **생성자 주입을 권장**합니다. 그 이유는:

1. 테스트 용이성 (Spring 없이 순수 자바 테스트 가능)
2. 빠른 테스트 실행 속도
3. 불변성과 안전성 보장
4. 명확한 의존성 명시

필드 주입의 간결함은 매력적으로 보이지만, 테스트와 유지보수 관점에서는 생성자 주입이 훨씬 우수합니다. 특히 테스트가 수백, 수천 개로 늘어날수록 생성자 주입의 이점은 더욱 명확해집니다.