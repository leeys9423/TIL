# 인덱스 톺아보기

## 인덱스란?

특정 데이터를 빠르게 찾을 수 있도록 도와주는 자료구조

## 인덱스의 작동 원리

### B-Tree

```
      [50]
     /    \
  [25]    [75]
  /  \    /  \
[10][40][60][90]
```

- **균형 트리** 구조로 모든 리프 노드가 같은 깊이에 위치
- **시간 복잡도**: O(log n)으로 매우 빠른 탐색 기능
- **범위 검색**에 최적화되어 있음

### B+Tree 인덱스 (실제 DBMS에서 주로 사용)

```
내부 노드:    [25|50|75]
           /   |   |   \
리프 노드: [10]→[25]→[50]→[75]→[90]
         (포인터로 연결)
```

- 모든 데이터가 리프 노드에만 저장: 내부 노드는 키만 저장
- 리프 노드 간 연결: 순차 접근이 매우 빠름
- 일관된 성능: 모든 데이터가 동일한 깊이에 있어 검색 시간 예측 가능
- 캐시 효율성: 내부 노드가 더 작아서 메모리 효율적

### Hash 인덱스

```
hash(key) → bucket → data
```

- 등가 비교(`=`)에 최적화
- 범위 검색 불가능
- 시간 복잡도: O(1) - 이론적으로 가장 빠름

## 인덱스 종류별 특징

### 1. 클러스터드 인덱스 (Clustered Index)

- 실제 데이터가 인덱스 순서대로 물리적으로 정렬됨
- 테이블당 **하나만** 생성 가능
- 보통 Primary Key에 자동으로 생성

### 2. 논클러스터드 인덱스 (Non-Clustered Index)

- 실제 데이터는 별도 위치에 저장
- 여러 개 생성 가능
- 인덱스 -> 데이터 위치 포인터 -> 실제 데이터

### 3. 복합 인덱스 (Composite Index)

- 여러 컬럼을 조합한 인덱스
- 컬럼 순서가 중요

## 인덱스 성능 최적화 전략

### 1. 카디널리티 (Cardinality) 고려

카디널리티란? 데이터베이스에서 **특정 컬럼이 가질 수 있는 고유한 값의 개수**를 의미 (쉽게 생각해서 높은 카디널리티 = 고유한 값이 많다!!)

```sql
-- 좋은 예: 높은 카디널리티
CREATE INDEX idx_user_email ON users(email);

-- 나쁜 예: 낮은 카디널리티
CREATE INDEX idx_user_gender ON users(gender); -- M/F 두 값만 존재
```

### 2. 실행 계획 분석

```sql
-- MySQL
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- PostgreSQL
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';
```

### 3. 인덱스 힌트 사용

```sql
-- MySQL
SELECT * FROM users USE INDEX (idx_name) WHERE name = 'John';

-- PostgreSQL는 힌트 대신 통계 정보 업데이트
ANALYZE users;
```

## 인덱스 생성 시 고려사항

### 언제 인덱스를 생성해야 할까?

- WHERE절에서 자주 사용되는 컬럼
- JOIN조건에서 사용되는 컬럼
- ORDER BY에서 사용되는 컬럼
- GROUP BY에서 사용되는 컬럼

### 인덱스를 피해야 하는 경우

- INSERT/UPDATE/DELETE가 빈번한 테이블
- 작은 테이블(수천 개 이하 레코드)
- 카디널리티 낮은 컬럼

## 헷갈렸던 점

**WHERE절 조건 순서**와 **복합 인덱스 컬럼 순서**는 다른 개념!!

WHERE 절에서는 순서가 성능에 큰 영향이 없다 (옵티마이저가 알아서 최적화)

## 마무리

다음에는 인덱스에 대해 "옵티마이저는 어떻게 Full Scan과 Index Scan 사이에서 고민할까?", "수백만 건의 데이터에서 LIKE '%검색어%' 쿼리를 어떻게 최적화할 수 있을까?" 와 같은 실전 심화 주제에 대해서 글을 쓸 예정이다!
